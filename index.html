<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tripti's World</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            /* Sky Blue */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
            /* Prevent text selection during gameplay */
        }

        canvas {
            display: block;
        }

        /* UI Overlay Styles */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .ui-element {
            pointer-events: auto;
        }

        /* Error Overlay */
        #error-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            color: red;
            font-family: monospace;
            padding: 20px;
            z-index: 10000;
            display: none;
            pointer-events: auto;
            white-space: pre-wrap;
        }
    </style>
    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>
    <div id="error-overlay"></div>
    <script>
        // Global Error Handler
        window.onerror = function (msg, url, line, col, error) {
            const overlay = document.getElementById('error-overlay');
            overlay.style.display = 'block';
            overlay.innerHTML += `CRITICAL ERROR:\n${msg}\nLine: ${line}:${col}\n\nStack:\n${error ? error.stack : 'N/A'}`;
            return false;
        };

        try {
            // ==========================================
            // 1. GAME STATE & VARIABLES (Moved to Top)
            // ==========================================
            const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
            let inventory = [];
            let badges = 0;
            const totalBadges = 5;
            const awardedBadges = new Set();
            let playerCanMove = true; // Control flag for movement
            let gameWon = false; // Flag to prevent multiple wins
            let isSittingWithSuga = false; // Flag for Suchwita interaction
            let isSittingInPhotobooth = false;
            let suchwitaTableGroup; // Global reference for food spawning
            let mcdWaiter; // Global reference for McDonald's Waiter
            let mcdTable1; // Global reference for McDonald's Table 1
            let mcdCart = []; // McDonald's Cart
            let pvrCart = []; // PVR Cart
            let selectedPvrMovie = null;
            let pvrSnackGroup; // PVR Snacks Group

            // Suchwita State
            let suchwitaCart = [];
            let selectedSong = null;
            // Waiter State
            let waiterState = 'idle'; // 'idle', 'delivering', 'returning'
            let waiterTarget = new THREE.Vector3();
            const waiterHomePos = new THREE.Vector3(0, 0.6, -4); // Behind counter

            // Karaoke Order State
            // let currentOrder = { food: [], song: null }; // This is now handled by suchwitaCart and selectedSong
            const spotifyLinks = {
                'Nanku': 'https://open.spotify.com/artist/3Nrfpe0tUJi4K4DXYWgMUX', // Placeholder/Re-used for now
                'BTS': 'https://open.spotify.com/artist/3Nrfpe0tUJi4K4DXYWgMUX',
                'Jeremy Zucker': 'https://open.spotify.com/artist/3gIRvgZssIb9aiirIg0nI3',
                'Taylor Swift': 'https://open.spotify.com/artist/06HL4z0CvFAsei5YN25k03',
                'The Weeknd': 'https://open.spotify.com/artist/1Xyo4u8uXC1ZmMpatF05PJ'
            }; // Flag for Photobooth interaction

            // Asset Loading
            const textureLoader = new THREE.TextureLoader();
            const triptiImages = [
                'WhatsApp Image 2025-12-03 at 3.53.24 PM.jpeg',
                'WhatsApp Image 2025-12-04 at 2.17.24 PM.jpeg',
                'WhatsApp Image 2025-12-04 at 5.51.11 PM.jpeg',
                'WhatsApp Image 2025-12-04 at 5.52.32 PM.jpeg',
                'WhatsApp Image 2025-12-04 at 5.52.33 PM (1).jpeg',
                'WhatsApp Image 2025-12-04 at 5.52.33 PM (2).jpeg',
                'WhatsApp Image 2025-12-04 at 5.52.33 PM.jpeg',
                'WhatsApp Image 2025-12-04 at 5.52.34 PM.jpeg'
            ];

            // Joystick State
            let joystickInput = { x: 0, y: 0 };

            // Create Joystick UI
            const joystickZone = document.createElement('div');
            joystickZone.id = 'joystick-zone';
            joystickZone.style.cssText = "position:fixed; bottom:30px; left:30px; width:120px; height:120px; background:rgba(50, 50, 50, 0.8); border:2px solid #555; border-radius:50%; z-index:9999; touch-action:none; display:none;"; // Hidden by default

            // Action Button (Bottom Right)
            const actionBtn = document.createElement('div');
            actionBtn.id = 'mobile-action-btn';
            actionBtn.style.cssText = "position:fixed; bottom:30px; right:30px; width:80px; height:80px; background:rgba(255, 255, 255, 0.2); border:2px solid white; border-radius:50%; z-index:9999; display:none; justify-content:center; align-items:center; color:white; font-weight:bold; font-family:sans-serif; font-size: 24px; user-select:none; pointer-events:auto;";
            actionBtn.innerText = "E";
            document.body.appendChild(actionBtn);

            // Strict Mobile Detection
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            // Show on mobile devices OR very small screens
            if (isMobile || window.innerWidth <= 768) {
                joystickZone.style.display = 'block';
                actionBtn.style.display = 'flex';
            }

            // Action Button Listener
            actionBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (activeInteraction) {
                    activeInteraction.action();
                    // Visual Feedback
                    actionBtn.style.background = "rgba(255, 255, 255, 0.5)";
                    setTimeout(() => actionBtn.style.background = "rgba(255, 255, 255, 0.2)", 100);
                }
            }, { passive: false });



            // Arrows
            const arrowStyle = "position:absolute; width:0; height:0; border-style:solid;";
            joystickZone.innerHTML = `
                <div style="${arrowStyle} border-width:0 10px 15px 10px; border-color:transparent transparent white transparent; top:5px; left:50%; transform:translateX(-50%);"></div> <!-- Up -->
                <div style="${arrowStyle} border-width:15px 10px 0 10px; border-color:white transparent transparent transparent; bottom:5px; left:50%; transform:translateX(-50%);"></div> <!-- Down -->
                <div style="${arrowStyle} border-width:10px 15px 10px 0; border-color:transparent white transparent transparent; top:50%; left:5px; transform:translateY(-50%);"></div> <!-- Left -->
                <div style="${arrowStyle} border-width:10px 0 10px 15px; border-color:transparent transparent transparent white; top:50%; right:5px; transform:translateY(-50%);"></div> <!-- Right -->
                <div id="joystick-stick" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:60px; height:60px; background:#AAAAAA; border-radius:50%; box-shadow: 0 0 10px black;"></div>
            `;
            document.body.appendChild(joystickZone);

            const stick = document.getElementById('joystick-stick');
            const maxRadius = 30; // 60 radius - 30 stick radius = 30 movement

            // Joystick Logic
            joystickZone.addEventListener('touchstart', handleJoystick, { passive: false });
            joystickZone.addEventListener('touchmove', handleJoystick, { passive: false });
            joystickZone.addEventListener('touchend', resetJoystick);

            function handleJoystick(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joystickZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Limit movement
                if (distance > maxRadius) {
                    const angle = Math.atan2(dy, dx);
                    dx = Math.cos(angle) * maxRadius;
                    dy = Math.sin(angle) * maxRadius;
                }

                // Move Stick
                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                // Update Input (-1 to 1)
                joystickInput.x = dx / maxRadius;
                joystickInput.y = dy / maxRadius;
            }

            function resetJoystick() {
                stick.style.transform = "translate(-50%, -50%)";
                joystickInput = { x: 0, y: 0 };
            }

            // Camera Control (Right Screen Touch)
            document.body.addEventListener('touchmove', (e) => {
                if (e.touches.length === 0) return;
                const touch = e.touches[0];
                if (touch.clientX > window.innerWidth / 2 && !isOrbiting) {
                    // Rotate Tripti based on horizontal movement
                    if (lastTouchX !== null) {
                        const deltaX = touch.clientX - lastTouchX;
                        tripti.rotation.y -= deltaX * 0.005;
                    }
                    lastTouchX = touch.clientX;
                }
            }, { passive: false });

            let lastTouchX = null;
            document.body.addEventListener('touchstart', (e) => {
                if (e.touches[0].clientX > window.innerWidth / 2) {
                    lastTouchX = e.touches[0].clientX;
                }
            });
            document.body.addEventListener('touchend', () => {
                lastTouchX = null;
            });

            let lastSitTime = 0;
            // Photobooth Key Listener
            window.addEventListener('keydown', (e) => {
                if (e.key.toLowerCase() === 'e' && isSittingInPhotobooth) {
                    // Prevent immediate trigger after sitting
                    if (Date.now() - lastSitTime < 1000) return;
                    takePhotoSequence();
                }
            });

            function takePhotoSequence() {
                if (!isSittingInPhotobooth) return;

                // Prevent multiple triggers
                if (document.getElementById('countdown').style.display === 'block') return;

                const countdown = document.getElementById('countdown');
                const flash = document.getElementById('flash-overlay');
                const resultModal = document.getElementById('photo-result-modal');

                // 1. Countdown
                countdown.style.display = 'block';
                let count = 3;
                countdown.innerText = count;

                const timer = setInterval(() => {
                    count--;
                    if (count > 0) {
                        countdown.innerText = count;
                    } else {
                        clearInterval(timer);
                        countdown.style.display = 'none';

                        // 2. Flash
                        flash.style.opacity = 1;
                        setTimeout(() => {
                            flash.style.opacity = 0;

                            // 3. Generate & Show Result
                            const container = document.getElementById('photo-strip-container');
                            container.innerHTML = ''; // Clear previous

                            // Pick 3 random unique images
                            const shuffled = [...triptiImages].sort(() => 0.5 - Math.random());
                            const selected = shuffled.slice(0, 3);

                            selected.forEach(imgSrc => {
                                const img = document.createElement('img');
                                img.src = imgSrc;
                                img.style.cssText = "width:280px; max-width:100%; display:block; border: 4px solid white; border-radius:2px; margin-bottom: 5px;";
                                container.appendChild(img);
                            });

                            // Force display block to ensure visibility
                            resultModal.style.display = 'block';

                            // 4. Exit Logic (Wait for user to click Keep)
                            const closeBtn = document.getElementById('close-photo-result');
                            // Remove any existing listeners to prevent duplicates
                            const newCloseBtn = closeBtn.cloneNode(true);
                            closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

                            newCloseBtn.onclick = () => {
                                resultModal.style.display = 'none';

                                // Rewards awarded AFTER viewing
                                awardBadge('Photogenic');
                                addItem("Tripti's Photos");

                                isSittingInPhotobooth = false;
                                playerCanMove = true;
                                // Teleport off stool
                                tripti.position.z += 1;
                                promptUI.innerText = "Press E to Interact";
                            };
                        }, 100);
                    }
                }, 1000);
            }

            // This array was the cause of the crash. Now it's defined first.
            const interactables = [];
            let activeInteraction = null;
            let promptUI; // Global reference
            const guestsList = [];
            const confettiList = [];
            const dogTails = [];
            const cafeDogs = [];

            // ==========================================
            // 2. SCENE SETUP
            // ==========================================
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 100); // Added fog for depth

            // Camera
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 8);

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -50;
            dirLight.shadow.camera.right = 50;
            dirLight.shadow.camera.top = 50;
            dirLight.shadow.camera.bottom = -50;
            scene.add(dirLight);

            // Ground
            const groundGeo = new THREE.PlaneGeometry(120, 120);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4caf50 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // ==========================================
            // 3. CHARACTERS
            // ==========================================

            // Helper for Photo Textures
            function createPhotoTexture(colorStr) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 80;
                const ctx = canvas.getContext('2d');
                // White Border
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 64, 80);
                // Colored Background
                ctx.fillStyle = colorStr;
                ctx.fillRect(5, 5, 54, 54);
                // Simple Face (Tripti)
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(32, 32, 15, 0, Math.PI * 2);
                ctx.fill();
                // Smile
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(32, 32, 10, 0.2, Math.PI - 0.2);
                ctx.stroke();

                return new THREE.CanvasTexture(canvas);
            }

            // Helper for Suga
            function createSugaNPC() {
                const suga = new THREE.Group();

                // Body Group
                const bodyGroup = new THREE.Group();
                suga.add(bodyGroup);

                // 1. Outfit Layering
                // White Tee (Base Torso)
                const teeGeo = new THREE.CylinderGeometry(0.24, 0.24, 0.58, 32);
                const teeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const tee = new THREE.Mesh(teeGeo, teeMat);
                tee.position.y = 0.3;
                bodyGroup.add(tee);

                // Cardigan Panels (Charcoal Grey/Black)
                const cardiMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const panelGeo = new THREE.BoxGeometry(0.15, 0.6, 0.35); // Width, Height, Depth

                // Left Panel
                const leftPanel = new THREE.Mesh(panelGeo, cardiMat);
                leftPanel.position.set(-0.2, 0.3, 0.05); // Offset to side
                leftPanel.rotation.y = 0.1; // Slight wrap
                bodyGroup.add(leftPanel);

                // Right Panel
                const rightPanel = new THREE.Mesh(panelGeo, cardiMat);
                rightPanel.position.set(0.2, 0.3, 0.05);
                rightPanel.rotation.y = -0.1;
                bodyGroup.add(rightPanel);

                // Back Panel (To cover back)
                const backPanel = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.1), cardiMat);
                backPanel.position.set(0, 0.3, -0.15);
                bodyGroup.add(backPanel);

                // 2. Head
                const headGeo = new THREE.SphereGeometry(0.2, 32, 32);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xFFE4C4 }); // Pale Warm Beige (Bisque)
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.75;
                suga.add(head);

                // 3. Hair (Refined Short Cut)
                const hairMat = new THREE.MeshStandardMaterial({ color: 0x050505 }); // Jet Black

                // Base Cap (Hemisphere on top)
                const hairCap = new THREE.Mesh(new THREE.SphereGeometry(0.21, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
                hairCap.position.y = 0.75;
                suga.add(hairCap);

                // Back & Sides (Short Cylinder)
                const hairSide = new THREE.Mesh(new THREE.CylinderGeometry(0.21, 0.21, 0.25, 32), hairMat);
                hairSide.position.set(0, 0.68, -0.05); // Pushed back
                hairSide.scale.set(1, 1, 0.8); // Flattened slightly
                suga.add(hairSide);

                // Bangs (Curtain)
                const bangGeo = new THREE.SphereGeometry(0.12, 16, 16);

                // Left Bang
                const leftBang = new THREE.Mesh(bangGeo, hairMat);
                leftBang.scale.set(1, 0.4, 0.8);
                leftBang.position.set(-0.08, 0.88, 0.18);
                leftBang.rotation.z = 0.2;
                leftBang.rotation.y = 0.1;
                suga.add(leftBang);

                // Right Bang
                const rightBang = new THREE.Mesh(bangGeo, hairMat);
                rightBang.scale.set(1, 0.4, 0.8);
                rightBang.position.set(0.08, 0.88, 0.18);
                rightBang.rotation.z = -0.2;
                rightBang.rotation.y = -0.1;
                suga.add(rightBang);

                // 4. Accessories
                // Pearl Necklace (Ring of spheres)
                const pearlGeo = new THREE.SphereGeometry(0.02, 8, 8);
                const pearlMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2, metalness: 0.5 });
                const necklaceGroup = new THREE.Group();
                necklaceGroup.position.set(0, 0.58, 0); // Neck base
                suga.add(necklaceGroup);

                for (let i = 0; i < 16; i++) {
                    const angle = (i / 16) * Math.PI * 2;
                    const p = new THREE.Mesh(pearlGeo, pearlMat);
                    p.position.set(0.16 * Math.cos(angle), -0.05 * Math.sin(angle), 0.16 * Math.sin(angle));
                    necklaceGroup.add(p);
                }

                // Silver Chain (Torus)
                const chainGeo = new THREE.TorusGeometry(0.17, 0.005, 8, 32, Math.PI); // Half circle
                const chainMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 1.0, roughness: 0.2 });
                const chain = new THREE.Mesh(chainGeo, chainMat);
                chain.position.set(0, 0.54, 0.05);
                chain.rotation.x = Math.PI / 2 + 0.2; // Lay flat-ish
                suga.add(chain);

                // Earrings (Silver Hoops)
                const earringGeo = new THREE.TorusGeometry(0.03, 0.005, 8, 16);
                const earringMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 1.0 });

                const leftEar = new THREE.Mesh(earringGeo, earringMat);
                leftEar.position.set(-0.2, 0.75, 0);
                leftEar.rotation.y = Math.PI / 2;
                suga.add(leftEar);

                const rightEar = new THREE.Mesh(earringGeo, earringMat);
                rightEar.position.set(0.2, 0.75, 0);
                rightEar.rotation.y = Math.PI / 2;
                suga.add(rightEar);

                // 5. Limbs (Sitting Pose)
                const armGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.5, 32);
                const armMat = new THREE.MeshStandardMaterial({ color: 0x222222 }); // Match Cardigan

                // Left Arm (Lap)
                const leftArmGroup = new THREE.Group();
                leftArmGroup.position.set(-0.3, 0.5, 0);
                suga.add(leftArmGroup);
                const laUpper = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.3), armMat);
                laUpper.position.y = -0.15;
                leftArmGroup.add(laUpper);
                const laLower = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.3), armMat);
                laLower.position.set(0, -0.4, 0.1);
                laLower.rotation.x = -Math.PI / 4;
                leftArmGroup.add(laLower);

                // Right Arm (Table)
                const rightArmGroup = new THREE.Group();
                rightArmGroup.position.set(0.3, 0.5, 0);
                suga.add(rightArmGroup);
                const raUpper = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.3), armMat);
                raUpper.position.y = -0.15;
                raUpper.rotation.z = -0.2; // Slight abduction
                rightArmGroup.add(raUpper);
                const raLower = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.35), armMat);
                raLower.position.set(0.1, -0.35, 0.2); // Forearm forward and out
                raLower.rotation.x = -Math.PI / 3;
                raLower.rotation.z = 0.2;
                rightArmGroup.add(raLower);

                // Legs (Sitting)
                const legGeo = new THREE.CylinderGeometry(0.1, 0.09, 0.45, 32);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x111111 }); // Black Slacks

                // Thighs (Horizontal)
                const leftThigh = new THREE.Mesh(legGeo, legMat);
                leftThigh.position.set(-0.15, 0.05, 0.25);
                leftThigh.rotation.x = -Math.PI / 2;
                suga.add(leftThigh);

                const rightThigh = new THREE.Mesh(legGeo, legMat);
                rightThigh.position.set(0.15, 0.05, 0.25);
                rightThigh.rotation.x = -Math.PI / 2;
                suga.add(rightThigh);

                // Calves (Vertical down)
                const calfGeo = new THREE.CylinderGeometry(0.09, 0.08, 0.45, 32);
                const leftCalf = new THREE.Mesh(calfGeo, legMat);
                leftCalf.position.set(-0.15, -0.2, 0.45); // Knee at z=0.45
                suga.add(leftCalf);

                const rightCalf = new THREE.Mesh(calfGeo, legMat);
                rightCalf.position.set(0.15, -0.2, 0.45);
                suga.add(rightCalf);

                return suga;
            }

            function createWaiterNPC() {
                const waiter = new THREE.Group();

                // Body (White Shirt)
                const bodyGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.6, 32);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.3;
                waiter.add(body);

                // Legs (Black Pants)
                const legGeo = new THREE.CylinderGeometry(0.1, 0.09, 0.5, 32);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x111111 });

                const leftLeg = new THREE.Mesh(legGeo, legMat);
                leftLeg.position.set(-0.15, -0.25, 0);
                waiter.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeo, legMat);
                rightLeg.position.set(0.15, -0.25, 0);
                waiter.add(rightLeg);

                // Apron (Red)
                const apronGeo = new THREE.BoxGeometry(0.52, 0.7, 0.05);
                const apronMat = new THREE.MeshStandardMaterial({ color: 0xDD2C00 });
                const apron = new THREE.Mesh(apronGeo, apronMat);
                apron.position.set(0, 0, 0.26); // Front of body/legs
                waiter.add(apron);

                // Head
                const headGeo = new THREE.SphereGeometry(0.2, 32, 32);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD }); // Skin
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.y = 0.75;
                waiter.add(head);

                // Cap (Red)
                const capGeo = new THREE.SphereGeometry(0.21, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
                const capMat = new THREE.MeshStandardMaterial({ color: 0xDD2C00 });
                const cap = new THREE.Mesh(capGeo, capMat);
                cap.position.y = 0.8;
                cap.rotation.x = -Math.PI / 2; // Sit on top
                waiter.add(cap);

                // Cap Visor
                const visorGeo = new THREE.BoxGeometry(0.3, 0.02, 0.2);
                const visor = new THREE.Mesh(visorGeo, capMat);
                visor.position.set(0, 0.8, 0.25);
                waiter.add(visor);

                // Arms (White Shirt)
                const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 32);

                // Left Arm (Holding Tray)
                const leftArm = new THREE.Mesh(armGeo, bodyMat);
                leftArm.position.set(-0.35, 0.4, 0.2);
                leftArm.rotation.x = -Math.PI / 2; // Point forward
                leftArm.rotation.z = -0.2;
                waiter.add(leftArm);

                // Right Arm (Holding Tray)
                const rightArm = new THREE.Mesh(armGeo, bodyMat);
                rightArm.position.set(0.35, 0.4, 0.2);
                rightArm.rotation.x = -Math.PI / 2; // Point forward
                rightArm.rotation.z = 0.2;
                waiter.add(rightArm);

                // Tray (Gray)
                const trayGeo = new THREE.BoxGeometry(1.0, 0.05, 0.8);
                const trayMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const tray = new THREE.Mesh(trayGeo, trayMat);
                tray.position.set(0, 0.4, 0.6); // End of arms
                waiter.add(tray);

                // Store tray reference in userData for easy access
                waiter.userData.tray = tray;
                tray.visible = false; // Hidden initially

                // Food on Tray
                // Burger
                const burgerBun = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0xD2691E }));
                burgerBun.position.set(-0.2, 0.1, 0);
                tray.add(burgerBun);
                const burgerMeat = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.05, 16), new THREE.MeshStandardMaterial({ color: 0x3e2723 }));
                burgerMeat.position.y = 0.08;
                burgerBun.add(burgerMeat);

                // Fries
                const friesBox = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.05), new THREE.MeshStandardMaterial({ color: 0xDD2C00 }));
                friesBox.position.set(0.2, 0.1, 0.1);
                tray.add(friesBox);
                const fries = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.02), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
                fries.position.y = 0.1;
                friesBox.add(fries);

                // Drink
                const drink = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }));
                drink.position.set(0.2, 0.15, -0.2);
                tray.add(drink);
                const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.3), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                straw.position.set(0, 0.1, 0);
                straw.rotation.z = 0.2;
                drink.add(straw);

                return waiter;
            }

            // Helper for Signs
            function createSign(text, width, height, textColor, bgColor) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                // Background
                ctx.fillStyle = bgColor;
                ctx.fillRect(0, 0, 512, 128);

                // Border
                ctx.strokeStyle = textColor;
                ctx.lineWidth = 10;
                ctx.strokeRect(0, 0, 512, 128);

                // Text
                ctx.fillStyle = textColor;
                ctx.font = 'bold 60px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 256, 64);

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshStandardMaterial({
                    map: tex,
                    emissive: bgColor,
                    emissiveIntensity: 0.5
                });
                const geo = new THREE.BoxGeometry(8, 2, 0.5);
                return new THREE.Mesh(geo, mat);
            }

            // Helper for PVR Sign (Rectangular)
            function createPVRSign() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');

                // Background (Jet Black)
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 512, 128);

                // Border (Gold)
                ctx.strokeStyle = '#FFD700';
                ctx.lineWidth = 10;
                ctx.strokeRect(0, 0, 512, 128);

                // Text "PVR CINEMAS"
                ctx.fillStyle = '#FFD700';
                ctx.font = '900 60px Arial'; // Heavy Bold
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('PVR CINEMAS', 256, 64);

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshStandardMaterial({
                    map: tex,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.2
                });
                const geo = new THREE.BoxGeometry(8, 2, 0.5);
                return new THREE.Mesh(geo, mat);
            }

            // Helper for Dog Cafe Sign (Cottage-core)
            function createCafeSign() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');

                // Background (Cream/Beige)
                ctx.fillStyle = '#FAEBD7';
                ctx.fillRect(0, 0, 512, 128);

                // Text "Ninjaâ€™s ðŸ¾ Cafe"
                ctx.fillStyle = '#5D4037'; // Warm Brown
                ctx.font = 'bold 50px "Comic Sans MS", "Chalkboard SE", sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Ninjaâ€™s ðŸ¾ Cafe', 256, 64);

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshStandardMaterial({
                    map: tex,
                    roughness: 0.8 // Wood-like
                });
                return mat;
            }

            // Helper for Photobooth Sign (Neon Memories)
            function createPhotoSign() {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');

                // Background (Hot Pink)
                ctx.fillStyle = '#FF1493';
                ctx.fillRect(0, 0, 512, 128);

                // Text "âœ¨ MEMORIES âœ¨"
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 60px "Courier New", monospace'; // Typewriter style
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('âœ¨ MEMORIES âœ¨', 256, 64);

                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.MeshStandardMaterial({
                    map: tex,
                    emissive: 0xFF1493,
                    emissiveIntensity: 0.5
                });
                const geo = new THREE.BoxGeometry(5, 1.2, 0.2);
                return new THREE.Mesh(geo, mat);
            }

            // Helper for Polaroid Texture
            function createPolaroidTexture(color) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 150;
                const ctx = canvas.getContext('2d');

                // White Frame
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, 128, 150);

                // Colored Photo Area
                ctx.fillStyle = color;
                ctx.fillRect(10, 10, 108, 108);

                // Smiley Face
                ctx.fillStyle = '#000000';
                ctx.font = '40px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(':)', 64, 64);

                return new THREE.CanvasTexture(canvas);
            }

            // --- TRIPTI ---
            const tripti = new THREE.Group();
            scene.add(tripti);

            // 1. Jeans (Bottoms)
            const legGeo = new THREE.CylinderGeometry(0.12, 0.1, 1.1, 32);
            const jeanMat = new THREE.MeshStandardMaterial({ color: 0x1565C0 }); // Mid-Blue Denim
            const leftLeg = new THREE.Mesh(legGeo, jeanMat);
            leftLeg.position.set(-0.15, 0.55, 0);
            leftLeg.castShadow = true;
            tripti.add(leftLeg);

            const rightLeg = new THREE.Mesh(legGeo, jeanMat);
            rightLeg.position.set(0.15, 0.55, 0);
            rightLeg.castShadow = true;
            tripti.add(rightLeg);

            // 2. Midriff (Skin)
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffcc80 });
            const midriffGeo = new THREE.CylinderGeometry(0.25, 0.28, 0.2, 32);
            const midriff = new THREE.Mesh(midriffGeo, skinMat);
            midriff.position.set(0, 1.2, 0); // Top of jeans
            midriff.castShadow = true;
            tripti.add(midriff);

            // 3. Crop Top (Black Tee)
            const topGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.35, 32);
            const topMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            const torso = new THREE.Mesh(topGeo, topMat);
            torso.position.set(0, 1.475, 0);
            torso.castShadow = true;
            tripti.add(torso);

            // Sleeves
            const sleeveGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.2, 32);
            const lSleeve = new THREE.Mesh(sleeveGeo, topMat);
            lSleeve.position.set(-0.32, 0.05, 0);
            lSleeve.rotation.z = Math.PI / 2;
            torso.add(lSleeve);

            const rSleeve = new THREE.Mesh(sleeveGeo, topMat);
            rSleeve.position.set(0.32, 0.05, 0);
            rSleeve.rotation.z = Math.PI / 2;
            torso.add(rSleeve);

            // Arms
            const armGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 32);
            const lArm = new THREE.Mesh(armGeo, skinMat);
            lArm.position.set(-0.38, -0.2, 0);
            lArm.rotation.z = 0.1;
            torso.add(lArm);

            const rArm = new THREE.Mesh(armGeo, skinMat);
            rArm.position.set(0.38, -0.2, 0);
            rArm.rotation.z = -0.1;
            torso.add(rArm);

            // 4. Head (Skin)
            const headGeo = new THREE.SphereGeometry(0.5, 32, 32);
            // skinMat already defined
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.set(0, 1.9, 0); // Lowered slightly
            head.castShadow = true;
            tripti.add(head);

            // 4. Eyes (Front is -Z)
            const eyeGeo = new THREE.SphereGeometry(0.12, 16, 16);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const pupilGeo = new THREE.SphereGeometry(0.05, 16, 16);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

            // Left Eye
            const lEye = new THREE.Mesh(eyeGeo, eyeMat);
            lEye.position.set(-0.15, 0.1, -0.4); // Relative to head
            head.add(lEye);
            const lPupil = new THREE.Mesh(pupilGeo, pupilMat);
            lPupil.position.set(0, 0, -0.1); // Relative to eye
            lEye.add(lPupil);

            // Right Eye
            const rEye = new THREE.Mesh(eyeGeo, eyeMat);
            rEye.position.set(0.15, 0.1, -0.4);
            head.add(rEye);
            const rPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rPupil.position.set(0, 0, -0.1);
            rEye.add(rPupil);

            // 5. Hair (Mid-Length Straight Black)
            const hairMat = new THREE.MeshStandardMaterial({ color: 0x050505 }); // Jet Black

            // Top of Head
            const hairTop = new THREE.Mesh(new THREE.SphereGeometry(0.52, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
            hairTop.position.set(0, 0.05, 0);
            head.add(hairTop);

            // Straight Back Hair
            const hairBackGeo = new THREE.BoxGeometry(0.8, 0.8, 0.3);
            const hairBack = new THREE.Mesh(hairBackGeo, hairMat);
            hairBack.position.set(0, -0.2, 0.35); // Behind head, extending down
            head.add(hairBack);

            // 6. Earrings (Gold Hoops)
            const earringGeo = new THREE.TorusGeometry(0.08, 0.02, 8, 16);
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });

            const leftEarring = new THREE.Mesh(earringGeo, goldMat);
            leftEarring.position.set(-0.52, 0, 0); // Slightly wider to clear hair
            leftEarring.rotation.y = Math.PI / 2;
            head.add(leftEarring);

            const rightEarring = new THREE.Mesh(earringGeo, goldMat);
            rightEarring.position.set(0.52, 0, 0); // Slightly wider to clear hair
            rightEarring.rotation.y = Math.PI / 2;
            head.add(rightEarring);

            // 7. Accessories
            // Tote Bag (White Box on Shoulder)
            const bag = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 0.15), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            // Adjusted position for Crop Top
            bag.position.set(0.35, -0.1, 0.1);
            bag.rotation.z = -0.1; // Slight tilt
            torso.add(bag);

            // Keychain
            const key = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshStandardMaterial({ color: 0xffeb3b }));
            key.position.set(0, -0.2, 0.1);
            bag.add(key);

            // --- NINJA (DOG) ---
            const ninja = new THREE.Group();
            ninja.position.set(-2, 0, -2);
            scene.add(ninja);

            const beigeMat = new THREE.MeshStandardMaterial({ color: 0xd2b48c }); // Beige
            const blackMat = new THREE.MeshStandardMaterial({ color: 0x111111 }); // Black

            // 1. Body
            const dBody = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.9), beigeMat);
            dBody.position.y = 0.5;
            dBody.castShadow = true;
            ninja.add(dBody);

            // 2. Head
            const dHead = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.4), beigeMat);
            dHead.position.set(0, 0.8, 0.5); // Slightly forward and up
            dHead.castShadow = true;
            ninja.add(dHead);

            // 3. Snout (Black)
            const snout = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.2), blackMat);
            snout.position.set(0, -0.05, 0.25); // Front of head
            dHead.add(snout);

            // 4. Ears (Black, Triangular/Rotated)
            const earGeo = new THREE.ConeGeometry(0.08, 0.2, 4);
            const leftEar = new THREE.Mesh(earGeo, blackMat);
            leftEar.position.set(-0.1, 0.25, 0);
            leftEar.rotation.z = 0.3;
            leftEar.rotation.y = Math.PI / 4;
            dHead.add(leftEar);

            const rightEar = new THREE.Mesh(earGeo, blackMat);
            rightEar.position.set(0.1, 0.25, 0);
            rightEar.rotation.z = -0.3;
            rightEar.rotation.y = -Math.PI / 4;
            dHead.add(rightEar);

            // 5. Legs (4 Distinct)
            const legGeoD = new THREE.CylinderGeometry(0.05, 0.04, 0.5);
            const legFL = new THREE.Mesh(legGeoD, beigeMat); legFL.position.set(-0.15, 0.25, 0.35); ninja.add(legFL);
            const legFR = new THREE.Mesh(legGeoD, beigeMat); legFR.position.set(0.15, 0.25, 0.35); ninja.add(legFR);
            const legBL = new THREE.Mesh(legGeoD, beigeMat); legBL.position.set(-0.15, 0.25, -0.35); ninja.add(legBL);
            const legBR = new THREE.Mesh(legGeoD, beigeMat); legBR.position.set(0.15, 0.25, -0.35); ninja.add(legBR);

            // 6. Tail (Beige Base, Black Tip)
            const tailGroup = new THREE.Group();
            tailGroup.position.set(0, 0.6, -0.45);
            tailGroup.rotation.x = Math.PI / 4; // Angled up
            ninja.add(tailGroup);

            const tailBase = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.4), beigeMat);
            tailBase.position.y = 0.2;
            tailGroup.add(tailBase);

            const tailTip = new THREE.Mesh(new THREE.SphereGeometry(0.06), blackMat);
            tailTip.position.y = 0.4;
            tailGroup.add(tailTip);

            // ==========================================
            // 4. WORLD GENERATION
            // ==========================================

            function createBuilding(width, height, depth, color) {
                const group = new THREE.Group();
                const mat = new THREE.MeshStandardMaterial({ color: color });

                // Walls (Hollow U-Shape)
                const back = new THREE.Mesh(new THREE.BoxGeometry(width, height, 1), mat);
                back.position.set(0, height / 2, -depth / 2);
                back.castShadow = true;
                group.add(back);

                const left = new THREE.Mesh(new THREE.BoxGeometry(1, height, depth), mat);
                left.position.set(-width / 2, height / 2, 0);
                left.castShadow = true;
                group.add(left);

                const right = new THREE.Mesh(new THREE.BoxGeometry(1, height, depth), mat);
                right.position.set(width / 2, height / 2, 0);
                right.castShadow = true;
                group.add(right);

                // Roof
                const roof = new THREE.Mesh(new THREE.BoxGeometry(width + 2, 0.5, depth + 2), mat);
                roof.position.y = height;
                roof.castShadow = true;
                group.add(roof);

                // Floor
                const floor = new THREE.Mesh(new THREE.PlaneGeometry(width, depth), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = 0.05;
                group.add(floor);

                return group;
            }

            function createWorld() {
                const radius = 25;
                const buildings = [
                    { name: 'McDonalds', color: 0xDD2C00, angle: 0 },
                    { name: 'Photobooth', color: 0xFFB6C1, angle: (Math.PI * 2) / 5 },
                    { name: 'SUCHWITA', color: 0x4B0082, angle: (Math.PI * 2 * 2) / 5 },
                    { name: 'PVR', color: 0x333333, angle: (Math.PI * 2 * 3) / 5 },
                    { name: 'DogCafe', color: 0xF5DEB3, angle: (Math.PI * 2 * 4) / 5 }
                ];

                buildings.forEach(b => {
                    const group = new THREE.Group();
                    // Position in circle
                    const x = radius * Math.sin(b.angle);
                    const z = radius * Math.cos(b.angle);
                    group.position.set(x, 0, z);
                    group.lookAt(0, 0, 0); // Face center

                    scene.add(group);

                    // Add Building Structure
                    group.add(createBuilding(12, 8, 10, b.color));

                    // Add Props & Interactions based on type
                    const worldPos = new THREE.Vector3(x, 0, z); // Approximate center of building

                    if (b.name === 'McDonalds') {
                        // --- Modern Glass Box Design ---

                        // 1. Structure (Dark Grey Main Block)
                        // We'll use the existing createBuilding helper but modify it or just add over it?
                        // The helper creates a hollow U-shape. Let's hide/remove the helper for this one 
                        // OR just build inside it. The helper is generic.
                        // Actually, the prompt says "Completely replace the McDonald's geometry generation".
                        // So we should NOT use `createBuilding` for McDonald's if we want full control, 
                        // OR we use `createBuilding` as the shell and add the facade.
                        // Let's use `createBuilding` for the basic shell (Grey) and add the custom facade/interior.

                        // The `createBuilding` call above (line 215) already made the shell.
                        // We just need to add the specific parts to `group`.

                        // Facade: Glass Wall (Front)
                        const glassGeo = new THREE.PlaneGeometry(8, 8);
                        const glassMat = new THREE.MeshStandardMaterial({
                            color: 0x87CEFA,
                            transparent: true,
                            opacity: 0.3,
                            side: THREE.DoubleSide
                        });
                        const glassWall = new THREE.Mesh(glassGeo, glassMat);
                        glassWall.position.set(-2, 4, 5); // Front is +Z (5). Shifted left to leave room for wood panel.
                        group.add(glassWall);

                        // Wood Panel (Vertical Strip) - Right
                        const woodGeo = new THREE.BoxGeometry(4, 8, 1);
                        const woodMat = new THREE.MeshStandardMaterial({ color: 0xDD2C00 }); // Classic Red
                        const woodPanel = new THREE.Mesh(woodGeo, woodMat);
                        woodPanel.position.set(4, 4, 5.05); // Right side of front, offset to fix Z-fighting
                        group.add(woodPanel);

                        // Wood Panel (Vertical Strip) - Left (Mirroring Right)
                        const leftPanel = new THREE.Mesh(woodGeo, woodMat);
                        leftPanel.position.set(-4, 4, 5.05); // Left side of front, offset to fix Z-fighting
                        group.add(leftPanel);

                        // Roof Overhang (Classic Red)
                        const roofGeo = new THREE.BoxGeometry(14, 0.5, 12);
                        const roofMat = new THREE.MeshStandardMaterial({ color: 0xDD2C00 }); // Classic Red
                        const roof = new THREE.Mesh(roofGeo, roofMat);
                        roof.position.y = 8.3; // Raised slightly to fix Z-fighting
                        group.add(roof);

                        // Branding: Golden Arches 'M'
                        const archMat = new THREE.MeshStandardMaterial({ color: 0xffeb3b });
                        const arch1 = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.2, 8, 20, Math.PI), archMat);
                        arch1.position.set(3, 6, 5.6); // On Wood Panel
                        group.add(arch1);
                        const arch2 = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.2, 8, 20, Math.PI), archMat);
                        arch2.position.set(5, 6, 5.6); // Next to it
                        group.add(arch2);

                        // Interior
                        // Counter (White)
                        const counter = new THREE.Mesh(new THREE.BoxGeometry(10, 1.2, 1), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        counter.position.set(0, 0.6, -3); // Back of room
                        group.add(counter);

                        // Kiosks (Black Tall Boxes)
                        const kioskGeo = new THREE.BoxGeometry(0.8, 2.5, 0.2);
                        const kioskMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
                        const k1 = new THREE.Mesh(kioskGeo, kioskMat); k1.position.set(-5, 1.25, 0); group.add(k1);
                        const k2 = new THREE.Mesh(kioskGeo, kioskMat); k2.position.set(-3.5, 1.25, 0); group.add(k2);

                        // Waiter NPC
                        mcdWaiter = createWaiterNPC();
                        mcdWaiter.position.set(0, 0.6, -4); // Behind counter
                        group.add(mcdWaiter);

                        // Seating (Red Chairs, White Tables)
                        const chairGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                        const chairMat = new THREE.MeshStandardMaterial({ color: 0xd32f2f }); // Red
                        const tableGeo = new THREE.CylinderGeometry(0.8, 0.8, 1.0);
                        const tableMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

                        // Set 1
                        const t1 = new THREE.Mesh(tableGeo, tableMat); t1.position.set(2, 0.5, 0); group.add(t1);
                        mcdTable1 = t1; // Store global reference
                        const c1 = new THREE.Mesh(chairGeo, chairMat); c1.position.set(2, 0.4, 1.2); group.add(c1);
                        const c2 = new THREE.Mesh(chairGeo, chairMat); c2.position.set(2, 0.4, -1.2); group.add(c2);

                        // Set 2
                        const t2 = new THREE.Mesh(tableGeo, tableMat); t2.position.set(5, 0.5, 0); group.add(t2);
                        const c3 = new THREE.Mesh(chairGeo, chairMat); c3.position.set(5, 0.4, 1.2); group.add(c3);
                        const c4 = new THREE.Mesh(chairGeo, chairMat); c4.position.set(5, 0.4, -1.2); group.add(c4);

                        // Add Interaction
                        interactables.push({
                            position: new THREE.Vector3(worldPos.x, 0, worldPos.z + 5), // Front of building
                            radius: 4.0,
                            label: 'Order Food',
                            type: 'action',
                            action: () => {
                                document.getElementById('mcd-menu').style.display = 'block';
                            }
                        });

                        // McDonald's Chairs (Sit)
                        const chairPositions = [
                            { pos: new THREE.Vector3(2, 0.4, 1.2), rot: Math.PI }, // c1
                            { pos: new THREE.Vector3(2, 0.4, -1.2), rot: 0 },      // c2
                            { pos: new THREE.Vector3(5, 0.4, 1.2), rot: Math.PI }, // c3
                            { pos: new THREE.Vector3(5, 0.4, -1.2), rot: 0 }       // c4
                        ];

                        chairPositions.forEach((cp, i) => {
                            interactables.push({
                                position: new THREE.Vector3(worldPos.x + cp.pos.x, 0, worldPos.z + cp.pos.z),
                                radius: 2.0,
                                label: 'Sit',
                                type: 'sit',
                                action: () => {
                                    playerCanMove = false;
                                    tripti.position.set(worldPos.x + cp.pos.x, 0.6, worldPos.z + cp.pos.z);
                                    tripti.rotation.y = cp.rot;

                                    // Prevent camera swing
                                    lastSitTime = Date.now();
                                    tripti.updateMatrixWorld();
                                    const relativeOffset = new THREE.Vector3(0, 4, 6);
                                    const cameraOffset = relativeOffset.applyMatrix4(tripti.matrixWorld);
                                    camera.position.copy(cameraOffset);
                                    camera.lookAt(tripti.position.x, tripti.position.y + 2, tripti.position.z);

                                    const dlg = document.getElementById('dialogue-overlay');
                                    dlg.innerText = "[Press X to Stand Up]";
                                    dlg.style.display = 'block';
                                }
                            });
                        });
                    }
                    else if (b.name === 'Photobooth') {
                        // --- Vintage Wooden Box Design ---

                        // 1. Exterior (Dark Wood / Charcoal)
                        group.traverse((child) => {
                            if (child.isMesh && child.material.color.getHex() === 0x333333) { // Old color
                                child.material.color.setHex(0x212121); // Dark Charcoal Wood
                            }
                        });

                        // 2. Silver Trim (Vertical Strips)
                        const trimGeo = new THREE.BoxGeometry(0.2, 8, 0.2);
                        const trimMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.8, roughness: 0.2 });

                        // Corners
                        const t1 = new THREE.Mesh(trimGeo, trimMat); t1.position.set(-3.9, 4, 4.9); group.add(t1);
                        const t2 = new THREE.Mesh(trimGeo, trimMat); t2.position.set(3.9, 4, 4.9); group.add(t2);
                        const t3 = new THREE.Mesh(trimGeo, trimMat); t3.position.set(-3.9, 4, -4.9); group.add(t3);
                        const t4 = new THREE.Mesh(trimGeo, trimMat); t4.position.set(3.9, 4, -4.9); group.add(t4);

                        // Door Frame Trim
                        const doorTrimGeo = new THREE.BoxGeometry(0.2, 6, 0.2);
                        const dt1 = new THREE.Mesh(doorTrimGeo, trimMat); dt1.position.set(-2.1, 3, 5); group.add(dt1);
                        const dt2 = new THREE.Mesh(doorTrimGeo, trimMat); dt2.position.set(2.1, 3, 5); group.add(dt2);
                        const dtTop = new THREE.Mesh(new THREE.BoxGeometry(4.4, 0.2, 0.2), trimMat); dtTop.position.set(0, 6.1, 5); group.add(dtTop);


                        // 3. Top Light Box (PHOTO BOOTH)
                        const boxGeo = new THREE.BoxGeometry(6, 1.5, 1);
                        const boxMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, emissive: 0x222222 });
                        const lightBox = new THREE.Mesh(boxGeo, boxMat);
                        lightBox.position.set(0, 8.75, 4.5); // Centered on roof
                        group.add(lightBox);

                        // Text Texture
                        const canvas = document.createElement('canvas');
                        canvas.width = 512; canvas.height = 128;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, 512, 128);
                        ctx.fillStyle = '#D32F2F'; // Bold Red
                        ctx.font = 'bold 60px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('PHOTO BOOTH', 256, 64);

                        const tex = new THREE.CanvasTexture(canvas);
                        const signFace = new THREE.Mesh(new THREE.PlaneGeometry(5.8, 1.3), new THREE.MeshBasicMaterial({ map: tex }));
                        signFace.position.set(0, 0, 0.51);
                        lightBox.add(signFace);


                        // 4. 'Hot Shots' Sign (Retro Script)
                        const hotShotCanvas = document.createElement('canvas');
                        hotShotCanvas.width = 256; hotShotCanvas.height = 128;
                        const hsCtx = hotShotCanvas.getContext('2d');
                        // Pill shape background
                        hsCtx.fillStyle = '#FFEB3B'; // Yellow
                        hsCtx.beginPath();
                        hsCtx.ellipse(128, 64, 120, 50, 0, 0, Math.PI * 2);
                        hsCtx.fill();
                        // Text
                        hsCtx.fillStyle = '#000000';
                        hsCtx.font = 'italic bold 40px "Brush Script MT", cursive';
                        hsCtx.textAlign = 'center';
                        hsCtx.textBaseline = 'middle';
                        hsCtx.fillText('Hot Shots', 128, 64);

                        const hsTex = new THREE.CanvasTexture(hotShotCanvas);
                        const hsSign = new THREE.Mesh(new THREE.PlaneGeometry(2, 1), new THREE.MeshBasicMaterial({ map: hsTex, transparent: true }));
                        hsSign.position.set(0, 7.2, 5.3); // Below light box, above door
                        group.add(hsSign);

                        // 5. Messy Photo Strips (Exterior Walls)
                        function createMessyPhoto() {
                            const canvas = document.createElement('canvas');
                            canvas.width = 64; canvas.height = 128;
                            const ctx = canvas.getContext('2d');
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, 64, 128);
                            ctx.fillStyle = '#222';
                            // 4 black squares
                            for (let i = 0; i < 4; i++) {
                                ctx.fillRect(8, 8 + i * 30, 48, 24);
                            }
                            const tex = new THREE.CanvasTexture(canvas);
                            return new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.8), new THREE.MeshStandardMaterial({ map: tex, side: THREE.DoubleSide }));
                        }

                        for (let i = 0; i < 40; i++) {
                            const strip = createMessyPhoto();
                            const isLeft = Math.random() > 0.5;
                            const wallX = isLeft ? -4.1 : 4.1; // Slightly off the wall (width 8, so radius 4)

                            // Random height between 1 and 6
                            const y = 1 + Math.random() * 5;
                            // Random z between -4 and 4
                            const z = (Math.random() * 8) - 4;

                            strip.position.set(wallX, y, z);
                            strip.rotation.y = isLeft ? -Math.PI / 2 : Math.PI / 2;
                            strip.rotation.z = (Math.random() * 0.4) - 0.2; // Messy tilt

                            // Slight offset to prevent z-fighting with each other
                            strip.position.x += (Math.random() * 0.05);

                            group.add(strip);
                        }

                        // 6. Photo Collection Slot (Front Bottom)
                        // Metal Plate
                        const slotPlate = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 1.0), new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.9, roughness: 0.2 }));
                        slotPlate.position.set(-2.5, 1.5, 5.1); // Bottom Left of entrance
                        group.add(slotPlate);

                        // Black Slot Hole
                        const slotHole = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.15), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                        slotHole.position.set(0, -0.2, 0.01);
                        slotPlate.add(slotHole);

                        // Yellow Arrow (Triangle)
                        const arrowShape = new THREE.Shape();
                        arrowShape.moveTo(-0.2, 0.2);
                        arrowShape.lineTo(0.2, 0.2);
                        arrowShape.lineTo(0, -0.1);
                        arrowShape.lineTo(-0.2, 0.2);
                        const arrowGeo = new THREE.ShapeGeometry(arrowShape);
                        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xFFEB3B, side: THREE.DoubleSide });
                        const arrow = new THREE.Mesh(arrowGeo, arrowMat);
                        arrow.position.set(0, 0.2, 0.01);
                        slotPlate.add(arrow);
                        // 2. Interior Decor (Polaroids)
                        const polaroidColors = ['#FFB7B2', '#B5EAD7', '#E2F0CB', '#FFDAC1', '#C7CEEA', '#F0E68C'];

                        // Back Wall Positions
                        const p1 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.2), new THREE.MeshStandardMaterial({ map: createPolaroidTexture(polaroidColors[0]) }));
                        p1.position.set(-1.5, 3, -4.9); p1.rotation.z = (Math.random() * 0.2 - 0.1); group.add(p1);

                        const p2 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.2), new THREE.MeshStandardMaterial({ map: createPolaroidTexture(polaroidColors[1]) }));
                        p2.position.set(1.5, 3.5, -4.9); p2.rotation.z = (Math.random() * 0.2 - 0.1); group.add(p2);

                        // Side Walls
                        const p3 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.2), new THREE.MeshStandardMaterial({ map: createPolaroidTexture(polaroidColors[2]) }));
                        p3.position.set(-5.9, 3, 0); p3.rotation.y = Math.PI / 2; p3.rotation.z = (Math.random() * 0.2 - 0.1); group.add(p3);

                        const p4 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.2), new THREE.MeshStandardMaterial({ map: createPolaroidTexture(polaroidColors[3]) }));
                        p4.position.set(-5.9, 2, 2); p4.rotation.y = Math.PI / 2; p4.rotation.z = (Math.random() * 0.2 - 0.1); group.add(p4);

                        const p5 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.2), new THREE.MeshStandardMaterial({ map: createPolaroidTexture(polaroidColors[4]) }));
                        p5.position.set(5.9, 3.2, -1); p5.rotation.y = -Math.PI / 2; p5.rotation.z = (Math.random() * 0.2 - 0.1); group.add(p5);

                        const p6 = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.2), new THREE.MeshStandardMaterial({ map: createPolaroidTexture(polaroidColors[5]) }));
                        p6.position.set(5.9, 2.5, 1.5); p6.rotation.y = -Math.PI / 2; p6.rotation.z = (Math.random() * 0.2 - 0.1); group.add(p6);

                        // 2. Entrance (Vintage Red Velvet Curtain)
                        // Gathered to the right side
                        const curtainGeo = new THREE.CylinderGeometry(0.8, 1.2, 6, 16, 1, true, 0, Math.PI);
                        const curtainMat = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.9, side: THREE.DoubleSide }); // Deep Velvet Red
                        const curtain = new THREE.Mesh(curtainGeo, curtainMat);
                        curtain.position.set(2.5, 3, 5); // Right side
                        curtain.rotation.y = Math.PI / 4; // Angled slightly
                        curtain.scale.set(1, 1, 0.5); // Flattened
                        group.add(curtain);

                        // Tie-back (Gold)
                        const tieGeo = new THREE.TorusGeometry(0.9, 0.1, 8, 20, Math.PI);
                        const tieMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.8 });
                        const tie = new THREE.Mesh(tieGeo, tieMat);
                        tie.position.set(2.5, 3, 5);
                        tie.rotation.z = -0.2;
                        group.add(tie);


                        // 3. Interior Mechanics

                        // Rug (Persian Style - Dark Red/Gold)
                        const rug = new THREE.Mesh(new THREE.BoxGeometry(3, 0.05, 4), new THREE.MeshStandardMaterial({ color: 0x5D0000 }));
                        rug.position.set(0, 0.02, 0);
                        group.add(rug);

                        // Back Wall (Deep Red Damask)
                        const backdrop = new THREE.Mesh(new THREE.PlaneGeometry(7.8, 5), new THREE.MeshStandardMaterial({ color: 0x5D0000, side: THREE.DoubleSide }));
                        backdrop.position.set(0, 2.5, -4.8); // Cover the back glass/wall
                        group.add(backdrop);

                        // Seat: Vintage Bench (Black Leather)
                        const benchGeo = new THREE.BoxGeometry(2.5, 0.5, 1.2);
                        const benchMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.4 }); // Black Leather
                        const stool = new THREE.Mesh(benchGeo, benchMat); // Variable name 'stool' kept for compatibility with interaction logic
                        stool.position.set(0, 0.3, 0); // Center

                        // Bench Legs
                        const legGeo = new THREE.BoxGeometry(0.1, 0.3, 0.1);
                        const legMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                        const l1 = new THREE.Mesh(legGeo, legMat); l1.position.set(-1, -0.4, 0.5); stool.add(l1);
                        const l2 = new THREE.Mesh(legGeo, legMat); l2.position.set(1, -0.4, 0.5); stool.add(l2);
                        const l3 = new THREE.Mesh(legGeo, legMat); l3.position.set(-1, -0.4, -0.5); stool.add(l3);
                        const l4 = new THREE.Mesh(legGeo, legMat); l4.position.set(1, -0.4, -0.5); stool.add(l4);

                        group.add(stool);

                        // Camera (Box + Lens)
                        const camGroup = new THREE.Group();
                        camGroup.position.set(0, 1.5, -4); // Back wall facing stool
                        group.add(camGroup);

                        const camBox = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.5), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                        camGroup.add(camBox);

                        const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.3), new THREE.MeshStandardMaterial({ color: 0x111111 }));
                        lens.rotation.x = Math.PI / 2;
                        lens.position.z = 0.3;
                        camGroup.add(lens);

                        // Red Button
                        const btnGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.1);
                        const btnMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
                        const button = new THREE.Mesh(btnGeo, btnMat);
                        button.position.set(0.6, 1.2, -3.8); // Near camera
                        button.rotation.x = Math.PI / 2;
                        group.add(button);

                        // Interaction: Sit
                        interactables.push({
                            position: new THREE.Vector3(worldPos.x, 0, worldPos.z + 5), // Entrance
                            radius: 3.0, // Interaction radius inside
                            label: 'Sit',
                            type: 'sit',
                            action: () => {
                                // Teleport Tripti to stool
                                isSittingInPhotobooth = true;
                                playerCanMove = false;

                                // Calculate world position of stool
                                const stoolWorldPos = new THREE.Vector3();
                                stool.getWorldPosition(stoolWorldPos);

                                tripti.position.copy(stoolWorldPos);
                                tripti.position.y = 0.6; // Sit on top
                                tripti.rotation.y = Math.PI; // Face camera (Back is -Z, so face -Z means rot 0? No, camera is at -4, entrance at +5. So face -Z.)
                                // Wait, camera is at -4 (local). Entrance is +5.
                                // Tripti should face -Z (local) to look at camera.
                                // Default rotation 0 faces +Z? Need to check Tripti's default.
                                // Usually 0 is +Z. So Math.PI is -Z.
                                tripti.rotation.y = Math.PI;

                                // Prevent camera swing & immediate photo
                                lastSitTime = Date.now();
                                tripti.updateMatrixWorld();
                                const relativeOffset = new THREE.Vector3(0, 4, 6);
                                const cameraOffset = relativeOffset.applyMatrix4(tripti.matrixWorld);
                                camera.position.copy(cameraOffset);
                                camera.lookAt(tripti.position.x, tripti.position.y + 2, tripti.position.z);

                                promptUI.innerText = "Press E to Take Photos";
                            }
                        });

                        // Booths (Existing code below...)
                        const boothGeo = new THREE.BoxGeometry(2, 3, 2);
                        const boothMat = new THREE.MeshStandardMaterial({ color: 0xffffff }); // White

                        // Booth 1
                        const b1 = new THREE.Mesh(boothGeo, boothMat);
                        b1.position.set(-3, 1.5, -3);
                        group.add(b1);
                        // Screen 1
                        const s1 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff }));
                        s1.position.set(0, 0.5, 1.01);
                        b1.add(s1);

                        // Booth 2
                        const b2 = new THREE.Mesh(boothGeo, boothMat);
                        b2.position.set(3, 1.5, -3);
                        group.add(b2);
                        // Screen 2
                        const s2 = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff }));
                        s2.position.set(0, 0.5, 1.01);
                        b2.add(s2);

                        // Mirror Station
                        const mirrorGeo = new THREE.PlaneGeometry(3, 4);
                        const mirrorMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.9, roughness: 0.1 });
                        const mirror = new THREE.Mesh(mirrorGeo, mirrorMat);
                        mirror.position.set(0, 3, -4.9); // Back wall center
                        group.add(mirror);

                        const shelf = new THREE.Mesh(new THREE.BoxGeometry(3, 0.2, 1), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        shelf.position.set(0, 1, -4.5);
                        group.add(shelf);

                        // Prop


                        // Polaroids on Walls
                        const photoColors = ['#FFC0CB', '#87CEEB', '#FFFFE0', '#E6E6FA', '#FFD700'];
                        const photoPositions = [
                            { x: -1.5, y: 2.5, z: -4.9, rot: 0.1 },
                            { x: 1.5, y: 2.8, z: -4.9, rot: -0.15 },
                            { x: 0, y: 3.5, z: -4.9, rot: 0.05 },
                            { x: -5.9, y: 2.5, z: 0, rot: 0.2, side: 'left' }, // Left Wall
                            { x: 5.9, y: 2.5, z: 0, rot: -0.1, side: 'right' } // Right Wall
                        ];

                        photoPositions.forEach((pos, i) => {
                            const pGeo = new THREE.PlaneGeometry(1, 1.2);
                            const pMat = new THREE.MeshBasicMaterial({
                                map: createPhotoTexture(photoColors[i % photoColors.length]),
                                side: THREE.DoubleSide
                            });
                            const photo = new THREE.Mesh(pGeo, pMat);

                            if (pos.side === 'left') {
                                photo.position.set(pos.x, pos.y, pos.z);
                                photo.rotation.y = Math.PI / 2;
                            } else if (pos.side === 'right') {
                                photo.position.set(pos.x, pos.y, pos.z);
                                photo.rotation.y = -Math.PI / 2;
                            } else {
                                photo.position.set(pos.x, pos.y, pos.z);
                            }

                            photo.rotation.z = pos.rot;
                            group.add(photo);
                        });
                        group.add(button);


                    }
                    else if (b.name === 'SUCHWITA') {
                        // --- Suchwita Style Design ---

                        // 1. Vibe (Dark Wood)
                        // Override floor
                        const floor = new THREE.Mesh(new THREE.PlaneGeometry(11.8, 9.8), new THREE.MeshStandardMaterial({ color: 0x3e2723 }));
                        floor.rotation.x = -Math.PI / 2;
                        floor.position.set(0, 0.11, 0);
                        group.add(floor);

                        // 2. Signage (SUCHWITA)
                        const canvas = document.createElement('canvas');
                        canvas.width = 256;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, 256, 64);
                        ctx.fillStyle = 'black';
                        ctx.font = 'bold 40px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('SUCHWITA', 128, 32);

                        const signTex = new THREE.CanvasTexture(canvas);
                        const signGeo = new THREE.BoxGeometry(4, 1, 0.2);
                        const signMat = new THREE.MeshStandardMaterial({ map: signTex });
                        const sign = new THREE.Mesh(signGeo, signMat);
                        sign.position.set(0, 6, 5.1); // Above entrance
                        group.add(sign);

                        // 2. Furniture
                        // Center Table
                        const table = new THREE.Mesh(new THREE.BoxGeometry(4, 0.8, 1.5), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
                        table.position.set(0, 0.4, 0);
                        group.add(table);

                        // Food Container Group
                        suchwitaTableGroup = new THREE.Group();
                        suchwitaTableGroup.position.set(0, 0.41, 0); // On top of table
                        table.add(suchwitaTableGroup);

                        // Chairs
                        const chairGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                        const chairMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a }); // Black leather
                        const c1 = new THREE.Mesh(chairGeo, chairMat); c1.position.set(-2.5, 0.4, 0); group.add(c1);
                        const c2 = new THREE.Mesh(chairGeo, chairMat); c2.position.set(2.5, 0.4, 0); group.add(c2);

                        // Place Suga (Host)
                        const suga = createSugaNPC();
                        suga.position.set(-2, 0.6, 0); // On Left Chair (c1 is at -2, 0.4, 0) - Adjusted height
                        suga.rotation.y = Math.PI / 2; // Face table
                        group.add(suga);

                        // Whiskey Glass Prop
                        const glassGeo = new THREE.CylinderGeometry(0.08, 0.08, 0.15, 16);
                        const glassMat = new THREE.MeshStandardMaterial({
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.3,
                            roughness: 0.1,
                            metalness: 0.9
                        });
                        const glass = new THREE.Mesh(glassGeo, glassMat);
                        glass.position.set(-1.4, 0.6, 0.2); // On table near Suga's hand
                        group.add(glass);

                        // Props (Bottles on Table)
                        const bGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.4);
                        const b1 = new THREE.Mesh(bGeo, new THREE.MeshStandardMaterial({ color: 0x00ff00, transparent: true, opacity: 0.8 }));
                        b1.position.set(0, 0.6, 0); group.add(b1);
                        const b2 = new THREE.Mesh(bGeo, new THREE.MeshStandardMaterial({ color: 0xaa0000, transparent: true, opacity: 0.8 }));
                        b2.position.set(0.5, 0.6, 0.2); group.add(b2);

                        // Interaction for Right Chair (Sit with Yoongi)
                        interactables.push({
                            position: new THREE.Vector3(worldPos.x + 2.5, 0, worldPos.z), // Right Chair
                            radius: 3.0,
                            label: 'Sit with Yoongi',
                            type: 'sit',
                            action: () => {
                                playerCanMove = false;
                                isSittingWithSuga = true;

                                // Teleport to Chair
                                tripti.position.set(worldPos.x + 2.5, 0.6, worldPos.z);
                                tripti.rotation.y = -Math.PI / 2; // Face Left (towards Suga)

                                // Prevent camera swing
                                lastSitTime = Date.now();
                                tripti.updateMatrixWorld();
                                const relativeOffset = new THREE.Vector3(0, 4, 6);
                                const cameraOffset = relativeOffset.applyMatrix4(tripti.matrixWorld);
                                camera.position.copy(cameraOffset);
                                camera.lookAt(tripti.position.x, tripti.position.y + 2, tripti.position.z);

                                // Show Dialogue
                                const dlg = document.getElementById('dialogue-overlay');
                                dlg.innerText = "Suga: Happy birthday Tripti.";
                                dlg.style.display = 'block';

                                // Hide after 4s
                                setTimeout(() => {
                                    if (isSittingWithSuga) { // Only hide if still sitting
                                        dlg.style.display = 'none';
                                        // Show prompt to stand up
                                        const prompt = document.querySelector('#ui-layer div:nth-child(2)'); // Hacky selector, better to use ID if possible.
                                        // Actually, let's just use a temporary alert or update the dialogue text.
                                        dlg.innerText = "[Press X to Stand Up]";
                                        dlg.style.display = 'block';
                                        dlg.style.fontSize = '18px';
                                        dlg.style.color = '#ccc';
                                    }
                                }, 4000);
                            }
                        });

                        interactables.push({
                            position: new THREE.Vector3(x, 1, z), // Center of building
                            radius: 6.0,
                            label: 'Attend SUCHWITA',
                            action: () => {
                                karaokeMenu.style.display = 'block';
                            }
                        });
                        // 3. Shelves (Back Wall)
                        const shelfGeo = new THREE.BoxGeometry(10, 0.1, 0.5);
                        const shelfMat = new THREE.MeshStandardMaterial({ color: 0x5d4037 });

                        for (let y = 2; y < 7; y += 1.5) {
                            const shelf = new THREE.Mesh(shelfGeo, shelfMat);
                            shelf.position.set(0, y, -4.5);
                            group.add(shelf);

                            // Bottles on Shelf
                            for (let x = -4; x < 4; x += 0.5) {
                                if (Math.random() > 0.3) {
                                    const color = Math.random() > 0.5 ? 0x2e7d32 : (Math.random() > 0.5 ? 0x8d6e63 : 0xffffff);
                                    const bottle = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5), new THREE.MeshStandardMaterial({ color: color }));
                                    bottle.position.set(x + Math.random() * 0.2, 0.3, 0);
                                    shelf.add(bottle);
                                }
                            }
                        }

                        // 4. Lighting (Warm Point Light)
                        const light = new THREE.PointLight(0xffaa00, 1, 15);
                        light.position.set(0, 6, 0);
                        group.add(light);
                        // Helper sphere to see light source
                        // group.add(new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshBasicMaterial({color:0xffaa00})));

                        interactables.push({
                            position: new THREE.Vector3(x, 1, z), // Center of building
                            radius: 6.0,
                            label: 'Attend SUCHWITA',
                            type: 'action',
                            action: () => {
                                karaokeMenu.style.display = 'block';
                            }
                        });
                    }
                    else if (b.name === 'PVR') {
                        // --- Multiplex Design ---

                        // 1. Exterior Signage (PVR CINEMAS)
                        const sign = createPVRSign();
                        sign.position.set(0, 9, 5.25); // Centered high above entrance
                        group.add(sign);

                        // 2. Posters (Emissive Planes)
                        const posterGeo = new THREE.PlaneGeometry(2, 3);
                        const p1 = new THREE.Mesh(posterGeo, new THREE.MeshStandardMaterial({ color: 0x0000ff, emissive: 0x000055 }));
                        p1.position.set(-4, 4, 5.1); group.add(p1);
                        const p2 = new THREE.Mesh(posterGeo, new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x550000 }));
                        p2.position.set(4, 4, 5.1); group.add(p2);
                        const p3 = new THREE.Mesh(posterGeo, new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x005500 }));
                        p3.rotation.y = Math.PI / 2;
                        p3.position.set(6.1, 4, 0); group.add(p3); // Side wall

                        // 3. Red Carpet (Entrance)
                        const carpetGeo = new THREE.PlaneGeometry(4, 8);
                        const carpetMat = new THREE.MeshStandardMaterial({ color: 0x8b0000 });
                        const carpet = new THREE.Mesh(carpetGeo, carpetMat);
                        carpet.rotation.x = -Math.PI / 2;
                        carpet.position.set(0, 0.11, 2); // Extending out
                        group.add(carpet);

                        // 4. Interior
                        // Red Flooring
                        const floor = new THREE.Mesh(new THREE.PlaneGeometry(11.8, 9.8), carpetMat);
                        floor.rotation.x = -Math.PI / 2;
                        floor.position.set(0, 0.12, 0); // Slightly above default floor
                        group.add(floor);

                        // Concession Stand
                        const stand = new THREE.Mesh(new THREE.BoxGeometry(8, 1.2, 1), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        stand.position.set(0, 0.6, -2);
                        group.add(stand);

                        // PVR Snack Group (For spawned items)
                        pvrSnackGroup = new THREE.Group();
                        pvrSnackGroup.position.set(0, 0.6, 0); // On top of stand
                        stand.add(pvrSnackGroup);

                        // Popcorn Machine
                        const pmGeo = new THREE.BoxGeometry(1, 1.5, 1);
                        const pmMat = new THREE.MeshStandardMaterial({ color: 0x88ccff, transparent: true, opacity: 0.3 });
                        const pm = new THREE.Mesh(pmGeo, pmMat);
                        pm.position.set(2, 1.35, 0); // On counter
                        stand.add(pm);

                        // Popcorn (Yellow Particles)
                        const popGeo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                        const popMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
                        for (let i = 0; i < 10; i++) {
                            const p = new THREE.Mesh(popGeo, popMat);
                            p.position.set(Math.random() * 0.8 - 0.4, Math.random() * 0.8 - 0.4, Math.random() * 0.8 - 0.4);
                            pm.add(p);
                        }

                        // Screen (Keep existing)
                        const screen = new THREE.Mesh(new THREE.PlaneGeometry(10, 6), new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
                        screen.position.set(0, 4, -4.4); // Back wall (Moved forward to avoid z-fighting)
                        group.add(screen);

                        interactables.push({
                            position: new THREE.Vector3(x, 1, z),
                            radius: 8.0,
                            label: 'Check Movies',
                            type: 'action',
                            action: () => {
                                pvrMenu.style.display = 'block';
                            }
                        });
                    }
                    else if (b.name === 'DogCafe') {
                        // --- Pet Cottage Design ---

                        // 1. Cottage Walls (Wheat)
                        // Override the default grey building if possible, or just build over it.
                        // Since createBuilding makes a grey box, we can hide it or just place our cottage slightly larger?
                        // Better: We can traverse and change the material of the existing box.
                        group.traverse((child) => {
                            if (child.isMesh && child.geometry.type === 'BoxGeometry') {
                                child.material.color.setHex(0xF5DEB3); // Wheat
                            }
                        });

                        // 2. Roof (Dark Brown Peaked)
                        // The default has a flat roof. Let's add a peaked roof on top.
                        const roofGeo = new THREE.ConeGeometry(9, 4, 4);
                        const roofMat = new THREE.MeshStandardMaterial({ color: 0x5D4037 }); // Dark Brown
                        const roof = new THREE.Mesh(roofGeo, roofMat);
                        roof.position.set(0, 10, 0); // Sit on top (8 + 2)
                        roof.rotation.y = Math.PI / 4; // Align with box
                        group.add(roof);

                        // 3. Striped Awning (Green/White)
                        const awningGroup = new THREE.Group();
                        awningGroup.position.set(0, 5.5, 5.1); // Above door
                        group.add(awningGroup);

                        const awningColors = [0x90EE90, 0xFFFFFF]; // Pastel Green, White
                        for (let i = 0; i < 5; i++) {
                            const segment = new THREE.Mesh(
                                new THREE.BoxGeometry(0.8, 0.1, 2),
                                new THREE.MeshStandardMaterial({ color: awningColors[i % 2] })
                            );
                            segment.position.set((i - 2) * 0.8, 0, 1);
                            segment.rotation.x = Math.PI / 6; // Angle down
                            awningGroup.add(segment);
                        }

                        // 4. Bone Sign
                        const signGroup = new THREE.Group();
                        signGroup.position.set(0, 7.5, 5.5);
                        group.add(signGroup);

                        // Bone Shaft
                        const boneShaft = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 3, 16),
                            new THREE.MeshStandardMaterial({ color: 0xffffff })
                        );
                        boneShaft.rotation.z = Math.PI / 2;
                        signGroup.add(boneShaft);

                        // Bone Knuckles
                        const knuckleGeo = new THREE.SphereGeometry(0.5);
                        const knuckleMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

                        const k1 = new THREE.Mesh(knuckleGeo, knuckleMat); k1.position.set(-1.5, 0.3, 0); signGroup.add(k1);
                        const k2 = new THREE.Mesh(knuckleGeo, knuckleMat); k2.position.set(-1.5, -0.3, 0); signGroup.add(k2);
                        const k3 = new THREE.Mesh(knuckleGeo, knuckleMat); k3.position.set(1.5, 0.3, 0); signGroup.add(k3);

                        const k4 = new THREE.Mesh(knuckleGeo, knuckleMat); k4.position.set(1.5, -0.3, 0); signGroup.add(k4);

                        // 5. Wooden Hanging Sign
                        const cafeSignGeo = new THREE.BoxGeometry(7, 1.5, 0.2);
                        const cafeSignMat = createCafeSign();
                        const cafeSign = new THREE.Mesh(cafeSignGeo, cafeSignMat);
                        cafeSign.position.set(0, 9.5, 5.5); // Above bone
                        cafeSign.rotation.z = 0.05; // Cute tilt
                        group.add(cafeSign);

                        // 5. Window Planters
                        const planterGeo = new THREE.BoxGeometry(2, 0.5, 0.5);
                        const planterMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 }); // SaddleBrown
                        const plantGeo = new THREE.SphereGeometry(0.3);
                        const plantMat = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // ForestGreen

                        function createPlanter(x, z, rotY) {
                            const pGroup = new THREE.Group();
                            pGroup.position.set(x, 3, z);
                            pGroup.rotation.y = rotY;
                            group.add(pGroup);

                            const box = new THREE.Mesh(planterGeo, planterMat);
                            pGroup.add(box);

                            for (let i = 0; i < 3; i++) {
                                const plant = new THREE.Mesh(plantGeo, plantMat);
                                plant.position.set((i - 1) * 0.6, 0.3, 0);
                                pGroup.add(plant);
                            }
                        }


                        createPlanter(5.1, 0, Math.PI / 2); // Right wall
                        createPlanter(-5.1, 0, -Math.PI / 2); // Left wall

                        // 6. Outdoor Patio
                        const patioTableGeo = new THREE.CylinderGeometry(1, 1, 0.8);
                        const patioTableMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
                        const stoolGeo = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                        const stoolMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

                        // Table 1
                        const pt1 = new THREE.Mesh(patioTableGeo, patioTableMat);
                        pt1.position.set(-2.5, 0.4, 7);
                        group.add(pt1);
                        // Stools
                        const s1 = new THREE.Mesh(stoolGeo, stoolMat); s1.position.set(-2.5, 0.3, 8.2); group.add(s1);
                        const s2 = new THREE.Mesh(stoolGeo, stoolMat); s2.position.set(-1.3, 0.3, 7); group.add(s2);

                        // Table 2
                        const pt2 = new THREE.Mesh(patioTableGeo, patioTableMat);
                        pt2.position.set(2.5, 0.4, 7);
                        group.add(pt2);
                        // Stools
                        const s3 = new THREE.Mesh(stoolGeo, stoolMat); s3.position.set(2.5, 0.3, 8.2); group.add(s3);
                        const s4 = new THREE.Mesh(stoolGeo, stoolMat); s4.position.set(3.7, 0.3, 7); group.add(s4);

                        // 7. Cozy Interior
                        // Rug (Pastel Blue)
                        const rug = new THREE.Mesh(
                            new THREE.CircleGeometry(3.5, 32),
                            new THREE.MeshStandardMaterial({ color: 0xB2EBF2 })
                        );
                        rug.rotation.x = -Math.PI / 2;
                        rug.position.y = 0.1;
                        group.add(rug);

                        // Play Tunnel (Orange)
                        const tunnel = new THREE.Mesh(
                            new THREE.CylinderGeometry(1, 1, 3, 32, 1, true), // Open ended
                            new THREE.MeshStandardMaterial({ color: 0xFFA500, side: THREE.DoubleSide })
                        );
                        tunnel.rotation.z = Math.PI / 2;
                        tunnel.position.set(-2, 1, 0);
                        group.add(tunnel);

                        // Dog Bowls
                        const bowlGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
                        const b1 = new THREE.Mesh(bowlGeo, new THREE.MeshStandardMaterial({ color: 0x2196F3 })); // Blue
                        b1.rotation.x = Math.PI / 2; b1.position.set(2, 0.1, 1); group.add(b1);

                        const b2 = new THREE.Mesh(bowlGeo, new THREE.MeshStandardMaterial({ color: 0xF44336 })); // Red
                        b2.rotation.x = Math.PI / 2; b2.position.set(2, 0.1, 0); group.add(b2);

                        const b3 = new THREE.Mesh(bowlGeo, new THREE.MeshStandardMaterial({ color: 0xFFEB3B })); // Yellow
                        b3.rotation.x = Math.PI / 2; b3.position.set(2, 0.1, -1); group.add(b3);

                        // 8. Warm Lighting
                        const cafeLight = new THREE.PointLight(0xffaa00, 1, 15);
                        cafeLight.position.set(0, 6, 0);
                        group.add(cafeLight);

                        // Interaction
                        interactables.push({
                            position: worldPos,
                            radius: 6,
                            label: 'Pet Dogs',
                            action: () => {
                                alert("You petted the dog!");
                                awardBadge('Doggo Friend');
                            }
                        });
                        // 9. Dog NPCs
                        function createDogNPC(name, color, x, z, rotY, isSleeping = false, type = 'standard') {
                            const dogGroup = new THREE.Group();
                            dogGroup.position.set(x, isSleeping ? 0.25 : 0.5, z);
                            dogGroup.rotation.y = rotY;
                            group.add(dogGroup);

                            // Geometry Settings based on Type
                            let bodySize = [0.6, 0.4, 0.9];
                            let headSize = [0.4, 0.4, 0.4];
                            let earType = 'box'; // 'box' or 'cone' or 'poodle'

                            if (type === 'chihuahua') {
                                bodySize = [0.3, 0.25, 0.5]; // Small body
                                headSize = [0.25, 0.25, 0.25]; // Small head
                                earType = 'cone'; // Big ears
                                dogGroup.position.y = 0.25; // Lower to ground
                            } else if (type === 'poodle') {
                                // Poodle settings handled in geometry creation
                                dogGroup.position.y = 0.4;
                            }

                            // Body
                            let body;
                            if (type === 'poodle') {
                                // Fluffy Body (Cluster of spheres)
                                const bodyGroup = new THREE.Group();
                                const sphereGeo = new THREE.SphereGeometry(0.25, 16, 16);
                                const bodyMat = new THREE.MeshStandardMaterial({ color: color });

                                const b1 = new THREE.Mesh(sphereGeo, bodyMat); b1.position.z = 0.2; bodyGroup.add(b1);
                                const b2 = new THREE.Mesh(sphereGeo, bodyMat); b2.position.z = -0.2; bodyGroup.add(b2);
                                const b3 = new THREE.Mesh(sphereGeo, bodyMat); b3.position.y = 0.1; bodyGroup.add(b3);

                                body = bodyGroup;
                            } else {
                                const bodyGeo = new THREE.BoxGeometry(...bodySize);
                                const bodyMat = new THREE.MeshStandardMaterial({ color: color });
                                body = new THREE.Mesh(bodyGeo, bodyMat);
                            }

                            if (isSleeping) {
                                body.rotation.z = Math.PI / 2;
                                body.position.y = 0.2;
                            }
                            dogGroup.add(body);

                            // Head
                            const headGroup = new THREE.Group();
                            headGroup.position.set(0, isSleeping ? 0.2 : (type === 'chihuahua' ? 0.35 : (type === 'poodle' ? 0.5 : 0.5)), type === 'chihuahua' ? 0.35 : 0.6);
                            if (isSleeping) headGroup.rotation.z = -Math.PI / 2;
                            dogGroup.add(headGroup);

                            if (type === 'poodle') {
                                const headSphere = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshStandardMaterial({ color: color }));
                                headGroup.add(headSphere);
                            } else {
                                const headBox = new THREE.Mesh(new THREE.BoxGeometry(...headSize), new THREE.MeshStandardMaterial({ color: 0x333333 })); // Dark Grey Head
                                headGroup.add(headBox);
                            }

                            // Muzzle
                            const muzzleSize = type === 'chihuahua' ? [0.1, 0.1, 0.15] : [0.2, 0.2, 0.2];
                            const muzzleMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                            let muzzle;
                            if (type === 'poodle') {
                                muzzle = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), muzzleMat);
                                muzzle.position.set(0, -0.05, 0.2);
                            } else {
                                muzzle = new THREE.Mesh(new THREE.BoxGeometry(...muzzleSize), muzzleMat);
                                muzzle.position.set(0, -0.05, type === 'chihuahua' ? 0.15 : 0.25);
                            }
                            headGroup.add(muzzle);

                            // Ears
                            const bodyMat = new THREE.MeshStandardMaterial({ color: color }); // Re-use for ears
                            if (earType === 'cone') {
                                // Chihuahua Ears (Big Triangles)
                                const earGeo = new THREE.ConeGeometry(0.08, 0.2, 4);
                                const earL = new THREE.Mesh(earGeo, bodyMat);
                                earL.position.set(-0.12, 0.2, 0);
                                earL.rotation.z = 0.5;
                                earL.rotation.y = -0.2;
                                headGroup.add(earL);

                                const earR = new THREE.Mesh(earGeo, bodyMat);
                                earR.position.set(0.12, 0.2, 0);
                                earR.rotation.z = -0.5;
                                earR.rotation.y = 0.2;
                                headGroup.add(earR);
                            } else if (type === 'poodle') {
                                // Poodle Ears (Fluffy Spheres)
                                const earGeo = new THREE.SphereGeometry(0.15, 16, 16);
                                const earL = new THREE.Mesh(earGeo, bodyMat); earL.position.set(-0.2, 0.1, 0); headGroup.add(earL);
                                const earR = new THREE.Mesh(earGeo, bodyMat); earR.position.set(0.2, 0.1, 0); headGroup.add(earR);
                            } else {
                                // Standard Ears
                                const earGeo = new THREE.BoxGeometry(0.1, 0.2, 0.1);
                                const earL = new THREE.Mesh(earGeo, bodyMat); earL.position.set(-0.2, 0.3, 0); headGroup.add(earL);
                                const earR = new THREE.Mesh(earGeo, bodyMat); earR.position.set(0.2, 0.3, 0); headGroup.add(earR);
                            }

                            // Tail
                            let tail;
                            if (type === 'poodle') {
                                tail = new THREE.Mesh(new THREE.SphereGeometry(0.1, 16, 16), bodyMat);
                                tail.position.set(0, 0.2, -0.4);
                            } else {
                                const tailGeo = new THREE.CylinderGeometry(0.03, 0.03, type === 'chihuahua' ? 0.3 : 0.6);
                                tail = new THREE.Mesh(tailGeo, bodyMat);
                                tail.position.set(0, 0.1, type === 'chihuahua' ? -0.3 : -0.5);
                                tail.rotation.x = Math.PI / 4;
                            }

                            if (isSleeping) tail.rotation.z = Math.PI / 2;
                            dogGroup.add(tail);
                            if (!isSleeping) dogTails.push(tail); // Only animate if awake

                            // Legs
                            if (!isSleeping) {
                                const legGeo = new THREE.CylinderGeometry(0.04, 0.04, type === 'chihuahua' ? 0.25 : 0.5);
                                const lx = type === 'chihuahua' ? 0.1 : 0.2;
                                const ly = type === 'chihuahua' ? -0.2 : -0.4;
                                const lz = type === 'chihuahua' ? 0.15 : 0.3;

                                const positions = [
                                    [-lx, ly, lz], [lx, ly, lz],
                                    [-lx, ly, -lz], [lx, ly, -lz]
                                ];

                                positions.forEach(pos => {
                                    const leg = new THREE.Mesh(legGeo, bodyMat);
                                    leg.position.set(...pos);
                                    dogGroup.add(leg);

                                    if (type === 'poodle') {
                                        // Ankle Puffs
                                        const puff = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), bodyMat);
                                        puff.position.y = -0.2; // Bottom of leg
                                        leg.add(puff);
                                    }
                                });
                            }

                            // Interaction
                            interactables.push({
                                position: new THREE.Vector3(worldPos.x + x, 0, worldPos.z + z), // Approx world pos (Fallback)
                                mesh: dogGroup, // Dynamic tracking
                                radius: 3.0,
                                label: `Pet ${name}`,
                                type: 'action',
                                action: () => {
                                    alert(`You petted ${name}!`);
                                    awardBadge('Doggo Friend');
                                    // Happy jump effect?
                                    if (!isSleeping) {
                                        let jumpY = 0;
                                        const jumpInt = setInterval(() => {
                                            jumpY += 0.1;
                                            dogGroup.position.y = (type === 'chihuahua' ? 0.25 : 0.5) + Math.sin(jumpY) * 0.5;
                                            if (jumpY > Math.PI) {
                                                clearInterval(jumpInt);
                                                dogGroup.position.y = type === 'chihuahua' ? 0.25 : 0.5;
                                            }
                                        }, 50);
                                    }
                                }
                            });

                            // AI State
                            if (!isSleeping) {
                                dogGroup.userData = {
                                    velocity: new THREE.Vector3(),
                                    isMoving: false,
                                    moveTimer: 0,
                                    homePos: new THREE.Vector3(worldPos.x + x, 0, worldPos.z + z),
                                    hopOffset: Math.random() * 100
                                };
                                cafeDogs.push(dogGroup);
                            }
                        }

                        // Place Dogs
                        createDogNPC('Snowy', 0xFFFFFF, -2.5, 8, 0); // Patio
                        createDogNPC('Brownie', 0x8D6E63, 2, 1, -Math.PI / 2); // Near Bowls
                        createDogNPC('Spot', 0x333333, -2, 0, Math.PI); // Near Tunnel
                        createDogNPC('Goldie', 0xFFD700, 0, 0, 0, true); // Rug (Sleeping)
                        createDogNPC('Bruno', 0xf0e68c, -2, 4, 0, false, 'chihuahua'); // Bruno!
                        createDogNPC('Holly', 0xffdab9, 2, -4, 0, false, 'poodle'); // Holly!
                    }
                });
            }
            createWorld();


            // ==========================================
            // 5. UI SETUP
            // ==========================================
            const uiLayer = document.createElement('div');
            uiLayer.id = 'ui-layer';
            document.body.appendChild(uiLayer);

            // Badge UI
            const badgeUI = document.createElement('div');
            badgeUI.style.cssText = "position:absolute; top:20px; right:20px; color:white; font-size:20px; font-weight:bold; text-shadow: 2px 2px 2px #000;";
            badgeUI.innerText = `Badges: 0/${totalBadges}`;
            uiLayer.appendChild(badgeUI);

            // Controls Cheat Sheet
            const controlsUI = document.createElement('div');
            controlsUI.style.cssText = "position:absolute; top:60px; right:20px; text-align:right; color:rgba(255, 255, 255, 0.8); font-size:14px; font-family:monospace; line-height:1.5; text-shadow: 1px 1px 2px black; pointer-events:none; background:rgba(0, 0, 0, 0.3); padding:10px; border-radius:5px;";
            controlsUI.innerHTML = `
                <b>Controls</b><br>
                Move: Arrow Keys<br>
                Look: Mouse<br>
                Interact: E<br>
                Sit: S<br>
                Inventory: I<br>
                Toggle Cam: M<br>
                Stop Walking: Q<br>
                Close Menus: X
            `;
            uiLayer.appendChild(controlsUI);

            // Prompt UI
            promptUI = document.createElement('div');
            promptUI.id = 'prompt-ui';
            promptUI.style.cssText = "position:absolute; bottom:100px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.7); color:white; padding:10px 20px; border-radius:8px; display:block; cursor:pointer; pointer-events:auto;";
            promptUI.innerText = "Press M to Toggle Camera | X to Close Menus | Press E to Interact";
            uiLayer.appendChild(promptUI);

            // Make Prompt Clickable
            promptUI.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (activeInteraction) {
                    activeInteraction.action();
                }
            }, { passive: false });
            promptUI.addEventListener('click', () => {
                if (activeInteraction) activeInteraction.action();
            });

            // Photobooth UI elements
            const flashOverlay = document.createElement('div');
            flashOverlay.id = 'flash-overlay';
            flashOverlay.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:white; opacity:0; pointer-events:none; z-index:1000; transition:opacity 0.1s;";
            uiLayer.appendChild(flashOverlay);

            const countdownDisplay = document.createElement('div');
            countdownDisplay.id = 'countdown';
            countdownDisplay.style.cssText = "position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); color:white; font-size:100px; font-weight:bold; text-shadow: 0 0 20px black; display:none; pointer-events:none; z-index:1001;";
            uiLayer.appendChild(countdownDisplay);

            const photoResultModal = document.createElement('div');
            photoResultModal.id = 'photo-result-modal';
            photoResultModal.style.cssText = "position:fixed; top:50%; left:50%; transform:translate(-50%, -50%); background:white; padding:20px; border-radius:5px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); z-index:2000; display:none; text-align:center; max-width:90%; max-height:90vh; overflow-y:auto; pointer-events: auto;";
            photoResultModal.innerHTML = `
                <div id="photo-strip-container" style="background:black; padding:10px; border-radius:2px; display:inline-flex; flex-direction:column; gap:10px; align-items:center;">
                    <!-- Images will be injected here -->
                </div>
                <p style="font-family:'Brush Script MT', cursive; font-size:24px; margin:15px 0 10px 0; color:#333;">Best Memories! â¤ï¸</p>
                <button id="close-photo-result" style="background:#333; color:white; border:none; padding:10px 20px; font-size:16px; cursor:pointer; border-radius:5px;">Keep in Album</button>
            `;
            uiLayer.appendChild(photoResultModal);

            // Inventory UI
            const inventoryUI = document.createElement('div');
            inventoryUI.id = 'inventory-panel';
            inventoryUI.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:white; padding:20px; display:none; border-radius:10px; min-width:200px; text-align:center; box-shadow: 0 0 20px rgba(0,0,0,0.5); pointer-events: auto;";
            inventoryUI.innerHTML = "<h2>Inventory</h2><ul id='inv-list' style='list-style:none; padding:0;'></ul>";
            uiLayer.appendChild(inventoryUI);
            // Menus (Hidden)

            // Global state for karaoke menu is defined at the top (suchwitaCart, selectedSong, spotifyLinks)

            const karaokeMenu = document.createElement('div');
            karaokeMenu.id = 'karaoke-menu';
            karaokeMenu.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(20, 20, 20, 0.98); color:white; padding:30px; display:none; border-radius:15px; min-width: 800px; border: 2px solid #5d4037; box-shadow: 0 0 30px rgba(0,0,0,0.8); font-family: sans-serif; pointer-events: auto;";

            // Layout (Dual-Column Interactive Dashboard)
            karaokeMenu.innerHTML = `
                <h2 style="text-align:center; color:#ffeb3b; margin-top:0; margin-bottom:20px; font-size: 28px; letter-spacing: 2px;">SUCHWITA STUDIO</h2>
                <div style="display:flex; gap:40px;">
                    <!-- Column 1: Food (Menu) -->
                    <div style="flex:1; border-right:1px solid #444; padding-right:20px;">
                        <h3 style="color:#ffcc80; border-bottom:1px solid #444; padding-bottom:10px;">Menu ðŸ±</h3>
                        <div id="food-options" style="display:flex; flex-direction:column; gap:10px;">
                            <button class="menu-btn" data-item="Strawberry Iced Tea">ðŸ“ Strawberry Iced Tea</button>
                            <button class="menu-btn" data-item="Eggroll Shawarma">ðŸŒ¯ Eggroll Shawarma</button>
                            <button class="menu-btn" data-item="Strawberry Cornflakes">ðŸ¥£ Strawberry Cornflakes</button>
                            <button class="menu-btn" data-item="Rum & Raisin Chocolate">ðŸ« Rum & Raisin Choco</button>
                        </div>
                    </div>

                    <!-- Column 2: Music (Setlist) -->
                    <div style="flex:1;">
                        <h3 style="color:#ffcc80; border-bottom:1px solid #444; padding-bottom:10px;">Setlist ðŸŽµ</h3>
                        <div id="song-options" style="display:flex; flex-direction:column; gap:10px;">
                            ${Object.keys(spotifyLinks).map(artist => `<button class="song-btn" data-artist="${artist}">ðŸŽ¤ ${artist}</button>`).join('')}
                        </div>
                    </div>
                </div>

                <!-- Footer: Cart & Action -->
                <div style="margin-top:30px; border-top:1px solid #444; padding-top:20px;">
                    <div style="background:#111; padding:10px; border-radius:5px; margin-bottom:15px; min-height:40px; color:#aaa; font-style:italic;" id="suchwita-cart-preview">
                        Cart: Empty
                    </div>
                    <div style="display:flex; gap:10px; justify-content:center;">
                        <button id="place-order-btn" style="background:#4caf50; color:white; border:none; padding:12px 30px; border-radius:25px; font-size:18px; font-weight:bold; cursor:pointer; transition: transform 0.1s;">Place Order âœ…</button>
                        <button id="cancel-order-btn" style="background:#f44336; color:white; border:none; padding:12px 30px; border-radius:25px; font-size:18px; font-weight:bold; cursor:pointer;">Close âŒ</button>
                    </div>
                </div>

                <style>
                    .menu-btn, .song-btn {
                        background: #333; color: white; border: 1px solid #555; padding: 10px; border-radius: 5px; cursor: pointer; text-align: left; transition: background 0.2s;
                    }
                    .menu-btn:hover, .song-btn:hover { background: #444; }
                    .menu-btn.selected { background: #5d4037; border-color: #ffcc80; }
                    .song-btn.selected { background: #1db954; border-color: #fff; color: black; font-weight: bold; }
                </style>
            `;
            uiLayer.appendChild(karaokeMenu);

            // Menu Logic
            const foodBtns = karaokeMenu.querySelectorAll('.menu-btn');
            const songBtns = karaokeMenu.querySelectorAll('.song-btn');
            const cartPreview = karaokeMenu.querySelector('#suchwita-cart-preview');
            const placeOrderBtn = karaokeMenu.querySelector('#place-order-btn');
            const cancelOrderBtn = karaokeMenu.querySelector('#cancel-order-btn');

            // Food Click
            foodBtns.forEach(btn => {
                btn.onclick = () => {
                    const item = btn.getAttribute('data-item');
                    suchwitaCart.push(item);

                    // Visual Feedback
                    btn.style.transform = "scale(0.95)";
                    setTimeout(() => btn.style.transform = "scale(1)", 100);

                    // Update Cart Text
                    cartPreview.innerText = "Cart: " + suchwitaCart.join(', ');
                    cartPreview.style.color = "white";
                    cartPreview.style.fontStyle = "normal";
                };
            });

            // Song Click
            songBtns.forEach(btn => {
                btn.onclick = () => {
                    // Deselect others
                    songBtns.forEach(b => b.classList.remove('selected'));
                    // Select this
                    btn.classList.add('selected');
                    selectedSong = btn.getAttribute('data-artist');
                };
            });

            // Place Order
            placeOrderBtn.onclick = () => {
                if (suchwitaCart.length === 0) {
                    alert("Please select some food! ðŸ±");
                    return;
                }
                if (!selectedSong) {
                    alert("Please select a song! ðŸŽµ");
                    return;
                }

                // 1. Spawn Food
                spawnSuchwitaFood(suchwitaCart);

                // 2. Open Spotify
                const link = spotifyLinks[selectedSong];
                if (link) window.open(link, '_blank');

                // 3. Award Badge
                awardBadge('Voice of Town');

                // 4. Close & Reset
                karaokeMenu.style.display = 'none';
                suchwitaCart = [];
                selectedSong = null;
                cartPreview.innerText = "Cart: Empty";
                songBtns.forEach(b => b.classList.remove('selected'));
                playerCanMove = true;
            };

            // Cancel
            cancelOrderBtn.onclick = () => {
                karaokeMenu.style.display = 'none';
                suchwitaCart = [];
                selectedSong = null;
                cartPreview.innerText = "Cart: Empty";
                songBtns.forEach(b => b.classList.remove('selected'));
                playerCanMove = true;
            };

            const pvrMenu = document.createElement('div');
            pvrMenu.id = 'pvr-menu';
            pvrMenu.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(10, 10, 10, 0.98); color:white; padding:30px; display:none; border-radius:15px; min-width: 800px; border: 2px solid #ffeb3b; box-shadow: 0 0 30px rgba(0,0,0,0.8); font-family: sans-serif; pointer-events: auto;";

            pvrMenu.innerHTML = `
                <h2 style="text-align:center; color:#ffeb3b; margin-top:0; margin-bottom:20px; font-size: 28px; letter-spacing: 2px;">PVR CINEMAS</h2>
                <div style="display:flex; gap:40px;">
                    <!-- Column 1: F&B Menu -->
                    <div style="flex:1; border-right:1px solid #444; padding-right:20px;">
                        <h3 style="color:#ffcc80; border-bottom:1px solid #444; padding-bottom:10px;">Snacks & Drinks ðŸ¿</h3>
                        <div id="pvr-food-options" style="display:flex; flex-direction:column; gap:10px; max-height: 250px; overflow-y: auto;">
                            <button class="pvr-item-btn" data-item="Classic Salted Popcorn">ðŸ¿ Classic Salted Popcorn</button>
                            <button class="pvr-item-btn" data-item="Cheese Popcorn">ðŸ§€ Cheese Popcorn</button>
                            <button class="pvr-item-btn" data-item="Pepsi (Large)">ðŸ¥¤ Pepsi (Large)</button>
                            <button class="pvr-item-btn" data-item="Nachos with Salsa">ðŸŒ® Nachos with Salsa</button>
                            <button class="pvr-item-btn" data-item="Chicken Hotdog">ðŸŒ­ Chicken Hotdog</button>
                        </div>
                        
                        <h4 style="color:#aaa; margin-top:20px; border-bottom:1px solid #444; padding-bottom:5px; margin-bottom: 10px;">Your Tray:</h4>
                        <div id="pvr-cart-container" style="background:#222; padding:10px; border-radius:5px; min-height: 100px; max-height: 150px; overflow-y: auto;">
                            <p id="pvr-empty-msg" style="color:#666; font-style:italic; margin:0; text-align:center; padding-top: 30px;">No snacks selected</p>
                            <ul id="pvr-cart-list" style="list-style:none; padding:0; margin:0;"></ul>
                        </div>
                    </div>

                    <!-- Column 2: Movie Selection -->
                    <div style="flex:1; display:flex; flex-direction:column; justify-content:center; align-items:center;">
                        <h3 style="color:#ffcc80; margin-bottom:20px;">Select Show ðŸŽ¬</h3>
                        
                        <div id="pvr-selected-movie" style="background:#222; padding:20px; border-radius:10px; width:100%; text-align:center; margin-bottom:20px; border: 1px solid #444;">
                            <span style="color:#aaa; font-style:italic;">No movie selected</span>
                        </div>

                        <button id="btn-open-gallery" style="background:#e50914; color:white; border:none; padding:15px 30px; border-radius:10px; font-size:18px; font-weight:bold; cursor:pointer; width:100%; margin-bottom: 20px;">
                            Browse Movie Gallery ðŸŽžï¸
                        </button>
                        
                        <button id="pvr-place-order" style="background:#4caf50; color:white; border:none; padding:15px 30px; border-radius:10px; font-size:20px; font-weight:bold; cursor:pointer; width:100%; opacity: 0.5; pointer-events: none;">
                            Place Order âœ…
                        </button>
                    </div>
                </div>
                <div style="text-align:center; margin-top:20px;">
                    <button class="close-btn" onclick="this.parentElement.parentElement.style.display='none'" style="background:#333; color:white; border:none; padding:10px 30px; border-radius:20px; cursor:pointer;">Close âŒ</button>
                </div>
                <style>
                    .pvr-item-btn {
                        background: #333; color: white; border: 1px solid #555; padding: 10px; border-radius: 5px; cursor: pointer; text-align: left; transition: background 0.2s;
                    }
                    .pvr-item-btn:hover { background: #444; }
                </style>
            `;
            uiLayer.appendChild(pvrMenu);

            // PVR Logic
            setTimeout(() => {
                const pvrBtns = pvrMenu.querySelectorAll('.pvr-item-btn');
                const btnGallery = pvrMenu.querySelector('#btn-open-gallery');

                function updatePvrCartUI() {
                    const list = document.getElementById('pvr-cart-list');
                    const emptyMsg = document.getElementById('pvr-empty-msg');

                    if (!list || !emptyMsg) return;

                    list.innerHTML = '';

                    if (pvrCart.length === 0) {
                        emptyMsg.style.display = 'block';
                    } else {
                        emptyMsg.style.display = 'none';
                        pvrCart.forEach((item, index) => {
                            const li = document.createElement('li');
                            li.style.cssText = "display:flex; justify-content:space-between; align-items:center; background:#333; margin-bottom:5px; padding:8px 10px; border-radius:3px; color:white; border-left: 3px solid #ffeb3b;";
                            li.innerHTML = `
                                <span>${item}</span>
                                <button class="remove-pvr-item" data-index="${index}" style="background:#e50914; color:white; border:none; border-radius:3px; cursor:pointer; padding:2px 8px; font-size:12px;">âœ•</button>
                            `;
                            list.appendChild(li);
                        });

                        // Add remove listeners
                        list.querySelectorAll('.remove-pvr-item').forEach(btn => {
                            btn.onclick = (e) => {
                                const idx = parseInt(e.target.getAttribute('data-index'));
                                pvrCart.splice(idx, 1);
                                updatePvrCartUI();
                            };
                        });
                    }
                }

                pvrBtns.forEach(btn => {
                    btn.onclick = () => {
                        const item = btn.getAttribute('data-item');
                        pvrCart.push(item);
                        updatePvrCartUI();

                        // Visual Feedback
                        btn.style.transform = "scale(0.95)";
                        setTimeout(() => btn.style.transform = "scale(1)", 100);
                    };
                });

                btnGallery.onclick = () => {
                    pvrMenu.style.display = 'none';
                    document.getElementById('movie-gallery-modal').style.display = 'block';
                };

                // Place Order Logic
                const placeOrderBtn = document.getElementById('pvr-place-order');
                if (placeOrderBtn) {
                    placeOrderBtn.onclick = () => {
                        if (!selectedPvrMovie) return;

                        // 1. Open Netflix
                        window.open(selectedPvrMovie.url, '_blank');

                        // 2. Spawn Snacks
                        if (pvrCart.length > 0) {
                            spawnPvrSnacks(pvrCart);
                            alert(`Enjoy ${selectedPvrMovie.title} with your snacks! ðŸ¿`);
                            pvrCart = []; // Clear cart
                            updatePvrCartUI();
                        } else {
                            alert(`Enjoy ${selectedPvrMovie.title}! ðŸŽ¬`);
                        }

                        // 3. Awards & Mode
                        awardBadge('Movie Buff');
                        triggerMovieMode();

                        // 4. Close Menu & Reset
                        pvrMenu.style.display = 'none';
                        playerCanMove = true;

                        // Reset Selection UI
                        selectedPvrMovie = null;
                        const movieDisplay = document.getElementById('pvr-selected-movie');
                        if (movieDisplay) {
                            movieDisplay.innerHTML = '<span style="color:#aaa; font-style:italic;">No movie selected</span>';
                            movieDisplay.style.borderColor = "#444";
                        }
                        placeOrderBtn.style.opacity = 0.5;
                        placeOrderBtn.style.pointerEvents = 'none';
                    };
                }
            }, 0);

            // Movie Gallery Modal
            const galleryModal = document.createElement('div');
            galleryModal.id = 'movie-gallery-modal';
            galleryModal.style.cssText = "position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(10, 10, 10, 0.98); color:white; padding:40px; display:none; border-radius:15px; border: 2px solid #e50914; text-align:center; min-width: 800px; max-height: 80vh; overflow-y: auto; pointer-events: auto; font-family: sans-serif;";

            // Movie Data
            const movies = [
                { title: 'Laila Majnu', color: '#E91E63', url: 'https://www.netflix.com/search?q=Laila%20Majnu' },
                { title: 'To All The Boys Trilogy', color: '#9C27B0', url: 'https://www.netflix.com/search?q=To%20All%20The%20Boys' },
                { title: 'Descendants of the Sun', color: '#2196F3', url: 'https://www.netflix.com/search?q=Descendants%20of%20the%20Sun' },
                { title: 'Kalank', color: '#FF9800', url: 'https://www.netflix.com/search?q=Kalank' },
                { title: 'Call Me By Your Name', color: '#4CAF50', url: 'https://www.netflix.com/search?q=Call%20Me%20By%20Your%20Name' },
                { title: 'Bulbbul', color: '#F44336', url: 'https://www.netflix.com/search?q=Bulbbul' },
                { title: 'Vincenzo', color: '#673AB7', url: 'https://www.netflix.com/search?q=Vincenzo' }
            ];

            // Generate Grid
            let moviesHTML = movies.map(m => `
                <div class="movie-card" data-url="${m.url}" style="background:${m.color}; height:200px; display:flex; align-items:center; justify-content:center; border-radius:10px; cursor:pointer; transition: transform 0.2s; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">
                    <h3 style="color:white; text-shadow: 1px 1px 2px black; padding:10px;">${m.title}</h3>
                </div>
            `).join('');

            galleryModal.innerHTML = `
                <h2 style="color:#e50914; margin-top:0; font-size: 32px; letter-spacing: 1px;">Now Showing ðŸŽ¬</h2>
                <div style="display:grid; grid-template-columns: repeat(3, 1fr); gap:20px; margin-top:20px; padding:10px;">
                    ${moviesHTML}
                </div>
                <div style="margin-top:30px;">
                    <button onclick="this.parentElement.parentElement.style.display='none'; document.getElementById('pvr-menu').style.display='block';" style="background:#333; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer; margin-right:10px;">Back to Menu</button>
                    <button onclick="this.parentElement.parentElement.style.display='none'; playerCanMove=true;" style="background:#e50914; color:white; border:none; padding:10px 20px; border-radius:5px; cursor:pointer;">Close</button>
                </div>
                <style>
                    .movie-card:hover { transform: scale(1.05); z-index: 10; }
                </style>
            `;
            uiLayer.appendChild(galleryModal);

            // Movie Click Logic
            setTimeout(() => {
                const cards = galleryModal.querySelectorAll('.movie-card');
                cards.forEach(card => {
                    card.onclick = () => {
                        const url = card.getAttribute('data-url');
                        const title = card.querySelector('h3').innerText;

                        // Set Selection
                        selectedPvrMovie = { title, url };

                        // Update PVR Menu UI
                        const movieDisplay = document.getElementById('pvr-selected-movie');
                        const placeOrderBtn = document.getElementById('pvr-place-order');

                        if (movieDisplay) {
                            movieDisplay.innerHTML = `<span style="color:#ffeb3b; font-weight:bold; font-size:18px;">${title}</span>`;
                            movieDisplay.style.borderColor = "#ffeb3b";
                        }

                        if (placeOrderBtn) {
                            placeOrderBtn.style.opacity = 1;
                            placeOrderBtn.style.pointerEvents = 'auto';
                        }

                        // Return to Menu
                        galleryModal.style.display = 'none';
                        pvrMenu.style.display = 'block';
                    };
                });
            }, 0);

            // Safety: Reset keys on window blur
            window.addEventListener('blur', () => {
                Object.keys(keys).forEach(key => keys[key] = false);
            });

            function triggerMovieMode() {
                // Dim lights
                const originalIntensity = dirLight.intensity;
                const originalAmbient = ambientLight.intensity;

                // Animate dimming
                let dimStep = 0;
                const dimInterval = setInterval(() => {
                    dimStep++;
                    dirLight.intensity = Math.max(0.1, originalIntensity - (dimStep * 0.05));
                    ambientLight.intensity = Math.max(0.1, originalAmbient - (dimStep * 0.05));

                    if (dimStep >= 20) clearInterval(dimInterval);
                }, 50);

                // Restore after 5 seconds
                setTimeout(() => {
                    dirLight.intensity = originalIntensity;
                    ambientLight.intensity = originalAmbient;
                    alert("Hope you enjoyed the movie preview! ðŸ¿");
                }, 5000);
            }

            function spawnPvrSnacks(items) {
                if (!pvrSnackGroup) return;
                // Clear previous
                while (pvrSnackGroup.children.length > 0) {
                    pvrSnackGroup.remove(pvrSnackGroup.children[0]);
                }

                items.forEach((item, index) => {
                    const snack = new THREE.Group();
                    // Random position on counter (avoiding popcorn machine at x=2)
                    // Stand is width 8 (-4 to 4). Machine is at 2.
                    // Safe range: -3.5 to 1.0
                    const x = (Math.random() * 4.5) - 3.5;
                    const z = (Math.random() - 0.5) * 0.5;
                    snack.position.set(x, 0, z);
                    snack.rotation.y = Math.random() * Math.PI;

                    if (item.includes('Popcorn')) {
                        // White Box
                        const box = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.4), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        box.position.y = 0.3;
                        snack.add(box);
                        // Yellow Top
                        const top = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.1, 0.35), new THREE.MeshStandardMaterial({ color: 0xffff00 }));
                        top.position.y = 0.6;
                        snack.add(top);
                    } else if (item.includes('Pepsi')) {
                        // Blue Cylinder
                        const can = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.5, 16), new THREE.MeshStandardMaterial({ color: 0x0000ff }));
                        can.position.y = 0.25;
                        snack.add(can);
                        // Straw
                        const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.6), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        straw.position.set(0.05, 0.3, 0);
                        straw.rotation.z = 0.2;
                        snack.add(straw);
                    } else if (item.includes('Nachos')) {
                        // Tray
                        const tray = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.3), new THREE.MeshStandardMaterial({ color: 0xffd54f })); // Yellowish
                        tray.position.y = 0.05;
                        snack.add(tray);
                        // Salsa
                        const salsa = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.05), new THREE.MeshStandardMaterial({ color: 0xd32f2f })); // Red
                        salsa.position.set(0.15, 0.1, 0);
                        snack.add(salsa);
                    } else if (item.includes('Hotdog')) {
                        // Bun
                        const bun = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.15, 0.2), new THREE.MeshStandardMaterial({ color: 0xf4a460 }));
                        bun.position.y = 0.075;
                        snack.add(bun);
                        // Sausage
                        const sausage = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.55), new THREE.MeshStandardMaterial({ color: 0x8b0000 }));
                        sausage.rotation.z = Math.PI / 2;
                        sausage.position.y = 0.1;
                        snack.add(sausage);
                    }

                    pvrSnackGroup.add(snack);
                });
            }

            // let mcdCart = []; // Removed local declaration to fix lint error
            const mcdMenu = document.createElement('div');
            mcdMenu.id = 'mcd-menu';
            mcdMenu.style.cssText = "position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(0,0,0,0.9); color:white; padding:20px; display:none; border-radius:10px; text-align:center; min-width: 300px; font-family: sans-serif; pointer-events: auto;";
            mcdMenu.innerHTML = `
                <h3 style="color:#ffeb3b; margin-top:0;">McDonald's Menu</h3>
                <div id="mcd-items" style="display:flex; flex-direction:column; gap:10px; margin-bottom:20px;">
                    <button class="mcd-item-btn" data-item="Cold Coffee (Extra Ice)" style="padding:10px; background:#333; color:white; border:1px solid #555; border-radius:5px; cursor:pointer;">ðŸ¥¤ Cold Coffee (Extra Ice)</button>
                    <button class="mcd-item-btn" data-item="Chicken Burger" style="padding:10px; background:#333; color:white; border:1px solid #555; border-radius:5px; cursor:pointer;">ðŸ” Chicken Burger</button>
                    <button class="mcd-item-btn" data-item="Fries & Ketchup" style="padding:10px; background:#333; color:white; border:1px solid #555; border-radius:5px; cursor:pointer;">ðŸŸ Fries & Ketchup</button>
                    <button class="mcd-item-btn" data-item="Pizza McPuff" style="padding:10px; background:#333; color:white; border:1px solid #555; border-radius:5px; cursor:pointer;">ðŸ• Pizza McPuff</button>
                </div>
                <div id="mcd-cart-display" style="background:#222; color:#aaa; padding:10px; margin-bottom:15px; border-radius:5px; font-style:italic;">Selected Items: None</div>
                <button id="btn-order-mcd" style="background:#DD2C00; color:white; border:none; padding:10px 20px; border-radius:5px; font-weight:bold; cursor:pointer;">Place Order</button>
                <button class="close-btn" onclick="this.parentElement.style.display='none'" style="background:#333; color:white; border:none; padding:10px 20px; border-radius:5px; margin-left:10px; cursor:pointer;">Close</button>
            `;
            uiLayer.appendChild(mcdMenu);

            // Wire up Order Button & Cart Logic
            setTimeout(() => {
                const mcdItemBtns = mcdMenu.querySelectorAll('.mcd-item-btn');
                const mcdCartDisplay = mcdMenu.querySelector('#mcd-cart-display');

                mcdItemBtns.forEach(btn => {
                    btn.onclick = () => {
                        const item = btn.getAttribute('data-item');
                        mcdCart.push(item);
                        mcdCartDisplay.innerText = "Selected Items: " + mcdCart.join(', ');
                        mcdCartDisplay.style.color = "white";
                        mcdCartDisplay.style.fontStyle = "normal";

                        // Visual feedback
                        const originalBg = btn.style.background;
                        btn.style.background = '#4caf50';
                        setTimeout(() => btn.style.background = originalBg, 200);
                    };
                });

                document.getElementById('btn-order-mcd').onclick = () => {
                    try {
                        if (mcdCart.length === 0) {
                            alert("Please select items first! ðŸ”");
                            return;
                        }

                        // Hide Menu
                        mcdMenu.style.display = 'none';

                        // Trigger Delivery
                        waiterState = 'delivering';
                        waiterTarget.set(2, 0.6, 0); // Target Table 1

                        // Safety check for waiter and tray
                        if (typeof mcdWaiter !== 'undefined' && mcdWaiter && mcdWaiter.userData && mcdWaiter.userData.tray) {
                            mcdWaiter.userData.tray.visible = true;
                        } else {
                            console.warn("Waiter or tray not found!");
                        }

                        if (typeof playSound === 'function') {
                            playSound();
                        }

                        // Reset Cart
                        mcdCart = [];
                        mcdCartDisplay.innerText = "Selected Items: None";
                        mcdCartDisplay.style.color = "#aaa";
                        mcdCartDisplay.style.fontStyle = "italic";
                    } catch (e) {
                        console.error("Error in McDonald's Order:", e);
                        alert("Error placing order: " + e.message);
                    }
                };
            }, 0);

            // Photobooth UI
            const countdownOverlay = document.createElement('div');
            countdownOverlay.id = 'countdown-overlay';
            countdownOverlay.style.cssText = "position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); color:white; font-size:100px; font-weight:bold; text-shadow: 0 0 20px black; display:none; pointer-events:none;";
            uiLayer.appendChild(countdownOverlay);





            // Dialogue Overlay (Suchwita)
            const dialogueOverlay = document.createElement('div');
            dialogueOverlay.id = 'dialogue-overlay';
            dialogueOverlay.style.cssText = "position:fixed; bottom:50px; left:50%; transform:translateX(-50%); background:rgba(0,0,0,0.8); color:white; padding:15px 30px; border-radius:30px; font-size:24px; font-family:sans-serif; display:none; text-align:center; border: 2px solid #5d4037;";
            uiLayer.appendChild(dialogueOverlay);

            // Stand Up Handler
            window.addEventListener('keydown', (e) => {
                if ((e.key === 'x' || e.key === 'X') && isSittingWithSuga) {
                    isSittingWithSuga = false;
                    playerCanMove = true;
                    dialogueOverlay.style.display = 'none';
                    // Teleport slightly away
                    // We need to know where the chair was. Hardcoding relative to building center for now.
                    // Building center is at worldPos. The chair is at local x=2.5.
                    // Let's just move Tripti forward relative to her current rotation.
                    // Or just reset to a known standing spot near the chair.
                    // Since we don't have the exact worldPos here easily without storing it,
                    // we can rely on Tripti's current position and just move her +Z slightly.
                    tripti.translateZ(2);
                }
            });


            // ==========================================
            // 6. BIRTHDAY PARTY ZONE (Area 6)
            // ==========================================
            const partyGroup = new THREE.Group();
            partyGroup.position.set(0, 0, 0); // Center of Map
            partyGroup.visible = false; // Hidden initially
            scene.add(partyGroup);

            // 1. Gazebo Platform
            const partyFloor = new THREE.Mesh(
                new THREE.CylinderGeometry(8, 8, 0.5, 32),
                new THREE.MeshStandardMaterial({ color: 0xFFC0CB }) // Pink
            );
            partyFloor.position.y = 0.25;
            partyFloor.receiveShadow = true;
            partyGroup.add(partyFloor);

            // 2. Pillars
            const pillarGeo = new THREE.CylinderGeometry(0.3, 0.3, 10, 16);
            const pillarMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const pillarRadius = 7.5;

            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const x = pillarRadius * Math.sin(angle);
                const z = pillarRadius * Math.cos(angle);

                const pillar = new THREE.Mesh(pillarGeo, pillarMat);
                pillar.position.set(x, 5, z);
                partyGroup.add(pillar);

                // Streamers (Helical Ribbon)
                const streamerColor = i % 2 === 0 ? 0x00FFFF : 0xFF00FF; // Cyan / Magenta
                const points = [];
                for (let j = 0; j <= 50; j++) {
                    const t = j / 50;
                    const h = t * 10; // Height 0 to 10
                    const r = 0.5; // Radius slightly larger than pillar
                    const theta = t * Math.PI * 8; // 4 turns
                    points.push(new THREE.Vector3(Math.cos(theta) * r, h, Math.sin(theta) * r));
                }
                const streamerPath = new THREE.CatmullRomCurve3(points);
                const streamerGeo = new THREE.TubeGeometry(streamerPath, 50, 0.05, 8, false);
                const streamerMat = new THREE.MeshStandardMaterial({ color: streamerColor, side: THREE.DoubleSide });
                const streamer = new THREE.Mesh(streamerGeo, streamerMat);
                streamer.position.set(x, 0, z); // Base of pillar
                partyGroup.add(streamer);

                // Fairy Lights (Helical String with Emissive Spheres)
                const lightPoints = [];
                for (let j = 0; j <= 40; j++) {
                    const t = j / 40;
                    const h = t * 10;
                    const r = 0.6; // Slightly wider than streamers
                    const theta = t * Math.PI * 6 + Math.PI; // Offset rotation

                    const lx = Math.cos(theta) * r;
                    const lz = Math.sin(theta) * r;

                    // Wire
                    lightPoints.push(new THREE.Vector3(lx, h, lz));

                    // Bulb
                    if (j % 2 === 0) {
                        const bulbColor = Math.random() > 0.5 ? 0xFFD700 : 0xFFFFFF; // Gold / White
                        const bulb = new THREE.Mesh(
                            new THREE.SphereGeometry(0.05, 8, 8),
                            new THREE.MeshStandardMaterial({ color: bulbColor, emissive: bulbColor, emissiveIntensity: 0.8 })
                        );
                        bulb.position.set(x + lx, h, z + lz);
                        partyGroup.add(bulb);

                        // Actual Light (Expensive, so limit or use low intensity)
                        // const pointLight = new THREE.PointLight(bulbColor, 0.2, 2);
                        // pointLight.position.copy(bulb.position);
                        // partyGroup.add(pointLight);
                    }
                }
                // Wire Mesh
                const wirePath = new THREE.CatmullRomCurve3(lightPoints);
                const wireGeo = new THREE.TubeGeometry(wirePath, 40, 0.01, 4, false);
                const wireMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
                const wire = new THREE.Mesh(wireGeo, wireMat);
                wire.position.set(x, 0, z);
                partyGroup.add(wire);
            }


            // 3. Roof (Canopy)
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(9, 4, 6), // Hexagonal
                new THREE.MeshStandardMaterial({ color: 0xE6E6FA }) // Pastel Purple
            );
            roof.position.y = 12; // 10 + 2
            partyGroup.add(roof);

            // 4. Fairy Lights
            const lightGeo = new THREE.SphereGeometry(0.15);
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xFFFF00 });

            for (let i = 0; i < 24; i++) {
                const angle = (i / 24) * Math.PI * 2;
                const x = pillarRadius * Math.sin(angle);
                const z = pillarRadius * Math.cos(angle);

                const bulb = new THREE.Mesh(lightGeo, lightMat);
                bulb.position.set(x, 10, z); // Top of pillars
                partyGroup.add(bulb);
            }

            // 4. Cake Table
            const tableGeo = new THREE.CylinderGeometry(2, 2, 1, 32);
            const tableMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.position.set(0, 0.5, 0); // On platform (0.25 + 0.5/2)
            table.castShadow = true;
            partyGroup.add(table);

            // 5. Birthday Cake (On Table)
            const cakeGroup = new THREE.Group();
            cakeGroup.position.set(0, 1, 0); // On top of table (y=1)
            partyGroup.add(cakeGroup);

            // Bottom Tier (Chocolate)
            const tier1 = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.8, 32), new THREE.MeshStandardMaterial({ color: 0x5d4037 }));
            tier1.position.y = 0.4;
            tier1.castShadow = true;
            cakeGroup.add(tier1);

            // Top Tier (Cream)
            const tier2 = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.8, 32), new THREE.MeshStandardMaterial({ color: 0xfffff0 }));
            tier2.position.y = 1.2; // 0.8 + 0.4
            tier2.castShadow = true;
            cakeGroup.add(tier2);

            // Icing Drips
            const icingGeo = new THREE.TorusGeometry(1, 0.1, 16, 32);
            const icingMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const icing = new THREE.Mesh(icingGeo, icingMat);
            icing.rotation.x = Math.PI / 2;
            icing.position.y = 1.6;
            cakeGroup.add(icing);

            // Sprinkles
            const sprinkleGeo = new THREE.BoxGeometry(0.05, 0.02, 0.05);
            for (let i = 0; i < 30; i++) {
                const sMat = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
                const sprinkle = new THREE.Mesh(sprinkleGeo, sMat);
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 0.9;
                sprinkle.position.set(r * Math.sin(angle), 1.61, r * Math.cos(angle));
                sprinkle.rotation.y = Math.random();
                cakeGroup.add(sprinkle);
            }

            // Candles & Flames
            const candleLights = [];
            const candleFlames = [];

            for (let i = 0; i < 5; i++) {
                const angle = (i / 5) * Math.PI * 2;
                const x = 0.6 * Math.sin(angle);
                const z = 0.6 * Math.cos(angle);

                // Candle Body
                const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.4), new THREE.MeshStandardMaterial({ color: 0xff69b4 }));
                candle.position.set(x, 1.8, z);
                cakeGroup.add(candle);

                // Flame
                const flame = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({ color: 0xffa500 }));
                flame.position.set(0, 0.25, 0);
                candle.add(flame);
                candleFlames.push(flame);

                // Light
                const cLight = new THREE.PointLight(0xffa500, 1, 3);
                cLight.position.set(0, 0.1, 0);
                flame.add(cLight);
                candleLights.push(cLight);
            }

            // 6. Balloons (On Pillars)
            const balloonColors = [0xAEC6CF, 0xFDFD96, 0xFFDAB9]; // Pastel Blue, Yellow, Peach

            // We need to access the pillar positions again. 
            // Since we didn't save them, we can recalculate or just loop 6 times.
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const px = 7.5 * Math.sin(angle);
                const pz = 7.5 * Math.cos(angle);

                const bunchGroup = new THREE.Group();
                bunchGroup.position.set(px, 4, pz); // Height 4 on pillar
                partyGroup.add(bunchGroup);

                for (let b = 0; b < 3; b++) {
                    const bColor = balloonColors[(i + b) % 3];
                    const balloon = new THREE.Mesh(new THREE.SphereGeometry(0.5), new THREE.MeshStandardMaterial({ color: bColor }));
                    // Offset slightly
                    balloon.position.set((Math.random() - 0.5) * 0.5, 0.5 + Math.random() * 0.5, (Math.random() - 0.5) * 0.5);
                    bunchGroup.add(balloon);

                    // String
                    const string = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 1), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                    string.position.set(balloon.position.x, 0, balloon.position.z);
                    bunchGroup.add(string);
                }
            }

            // 7. Lighting (Local PointLights)
            const partyLight = new THREE.PointLight(0xffaa00, 1, 30);
            partyLight.position.set(0, 8, 0);
            partyGroup.add(partyLight);

            // Friend NPC Builder
            function createFriendNPC(shirtColor, blazerColor, hasGlasses) {
                const group = new THREE.Group();

                // 1. Legs (Formal Trousers)
                const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const leftLeg = new THREE.Mesh(legGeo, legMat);
                leftLeg.position.set(-0.15, 0.4, 0);
                group.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo, legMat);
                rightLeg.position.set(0.15, 0.4, 0);
                group.add(rightLeg);

                // 2. Torso (Shirt)
                const torsoGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.7);
                const torsoMat = new THREE.MeshStandardMaterial({ color: shirtColor });
                const torso = new THREE.Mesh(torsoGeo, torsoMat);
                torso.position.set(0, 1.15, 0);
                group.add(torso);

                // 3. Blazer (Open Jacket Look)
                const blazerMat = new THREE.MeshStandardMaterial({ color: blazerColor });

                // Back Panel
                const backPanel = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.7, 0.1), blazerMat);
                backPanel.position.set(0, 1.15, 0.2);
                group.add(backPanel);

                // Left Panel
                const leftPanel = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.4), blazerMat);
                leftPanel.position.set(-0.25, 1.15, 0);
                group.add(leftPanel);

                // Right Panel
                const rightPanel = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.4), blazerMat);
                rightPanel.position.set(0.25, 1.15, 0);
                group.add(rightPanel);

                // 4. Head
                const headGeo = new THREE.SphereGeometry(0.25);
                const headMat = new THREE.MeshStandardMaterial({ color: 0xFFE0BD }); // Skin tone
                const head = new THREE.Mesh(headGeo, headMat);
                head.position.set(0, 1.65, 0);
                group.add(head);

                // 5. Hair (Long Black)
                const hairMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
                const hairTop = new THREE.Mesh(new THREE.SphereGeometry(0.26, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
                hairTop.position.set(0, 1.7, 0);
                group.add(hairTop);

                const hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.2), hairMat);
                hairBack.position.set(0, 1.5, 0.25); // Extending down back
                group.add(hairBack);

                // 6. Glasses (Optional)
                if (hasGlasses) {
                    const glassMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
                    const g1 = new THREE.Mesh(new THREE.TorusGeometry(0.06, 0.01, 8, 16), glassMat);
                    g1.position.set(-0.1, 1.65, -0.22);
                    g1.rotation.y = Math.PI / 6;
                    group.add(g1);

                    const g2 = new THREE.Mesh(new THREE.TorusGeometry(0.06, 0.01, 8, 16), glassMat);
                    g2.position.set(0.1, 1.65, -0.22);
                    g2.rotation.y = -Math.PI / 6;
                    group.add(g2);
                }

                return group;
            }

            // Spawn Friends
            const f1 = createFriendNPC(0xffffff, 0x222222, true); // White Shirt, Black Blazer, Glasses
            f1.position.set(-5, 0, -5);
            partyGroup.add(f1);
            guestsList.push(f1);

            const f2 = createFriendNPC(0xffc0cb, 0x000080, false); // Pink Shirt, Navy Blazer, No Glasses
            f2.position.set(5, 0, 5);
            partyGroup.add(f2);
            guestsList.push(f2);

            // Random Guest Generator
            function createRandomGuest() {
                const palette = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#FF9F43', '#A3CB38', '#54A0FF', '#D980FA'];
                const color = palette[Math.floor(Math.random() * palette.length)];
                const type = Math.floor(Math.random() * 3); // 0: Casual, 1: Dress, 2: Formal

                const group = new THREE.Group();

                if (type === 0) { // Casual
                    // Jeans
                    const legGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.8);
                    const legMat = new THREE.MeshStandardMaterial({ color: Math.random() > 0.5 ? 0x111111 : 0x000080 }); // Black or Navy
                    const leftLeg = new THREE.Mesh(legGeo, legMat);
                    leftLeg.position.set(-0.15, 0.4, 0);
                    group.add(leftLeg);
                    const rightLeg = new THREE.Mesh(legGeo, legMat);
                    rightLeg.position.set(0.15, 0.4, 0);
                    group.add(rightLeg);

                    // T-Shirt
                    const torso = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.25, 0.7),
                        new THREE.MeshStandardMaterial({ color: color })
                    );
                    torso.position.set(0, 1.15, 0);
                    group.add(torso);
                } else if (type === 1) { // Dress
                    const dress = new THREE.Mesh(
                        new THREE.ConeGeometry(0.35, 1.5, 32),
                        new THREE.MeshStandardMaterial({ color: color })
                    );
                    dress.position.set(0, 0.75, 0);
                    group.add(dress);
                } else { // Formal (Reuse Friend Logic)
                    return createFriendNPC(color, 0x222222, Math.random() > 0.7);
                }

                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25),
                    new THREE.MeshStandardMaterial({ color: 0xFFE0BD })
                );
                head.position.set(0, 1.65, 0);
                group.add(head);

                // Hair
                const hairColor = 0x111111;
                const isLongHair = Math.random() > 0.5;
                const hairMat = new THREE.MeshStandardMaterial({ color: hairColor });

                if (isLongHair) {
                    const hairTop = new THREE.Mesh(new THREE.SphereGeometry(0.26, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
                    hairTop.position.set(0, 1.7, 0);
                    group.add(hairTop);
                    const hairBack = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 0.2), hairMat);
                    hairBack.position.set(0, 1.5, 0.25);
                    group.add(hairBack);
                } else {
                    const hair = new THREE.Mesh(new THREE.SphereGeometry(0.26, 16, 16, 0, Math.PI * 2, 0, Math.PI / 1.5), hairMat);
                    hair.position.set(0, 1.7, 0);
                    group.add(hair);
                }

                return group;
            }

            // Spawn Random Guests
            for (let i = 0; i < 18; i++) {
                const guest = createRandomGuest();

                // Ring Position (Radius 6-9)
                const angle = Math.random() * Math.PI * 2;
                const radius = 6 + Math.random() * 3;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                guest.position.set(x, 0.5, z);

                // Look at Cake (Center)
                guest.lookAt(0, 1, 0);

                partyGroup.add(guest);
                guestsList.push(guest);
            }


            // ==========================================
            // 7. GAME LOGIC
            // ==========================================
            function checkInteractions() {
                if (!tripti) return;

                let nearby = null;
                const triptiPos = tripti.position;

                interactables.forEach(item => {
                    let dist;
                    if (item.mesh) {
                        // Dynamic Object (e.g. Dog)
                        const targetPos = new THREE.Vector3();
                        item.mesh.getWorldPosition(targetPos);
                        dist = triptiPos.distanceTo(targetPos);
                    } else {
                        // Static Object
                        dist = triptiPos.distanceTo(item.position);
                    }

                    if (dist < item.radius) {
                        nearby = item;
                    }
                });

                if (nearby) {
                    activeInteraction = nearby;
                    if (nearby.type === 'sit') {
                        promptUI.innerText = `Press M to Toggle Camera | X to Close Menus | Press S to ${nearby.label}`;
                    } else {
                        promptUI.innerText = `Press M to Toggle Camera | X to Close Menus | Press E to ${nearby.label}`;
                    }
                    promptUI.style.display = 'block';
                } else {
                    activeInteraction = null;
                    promptUI.innerText = "Press M to Toggle Camera | X to Close Menus | Press E to Interact";
                    promptUI.style.display = 'block'; // Or 'none' if you want to hide it when idle, but user request implies showing default text
                }
            }

            function awardBadge(name) {
                if (!awardedBadges.has(name)) {
                    awardedBadges.add(name);
                    badges++;
                    badgeUI.innerText = `Badges: ${badges}/${totalBadges}`;
                    alert(`Badge Unlocked: ${name}!`);
                    checkWinCondition();
                }
            }

            function addItem(item) {
                inventory.push(item);
                const list = document.getElementById('inv-list');
                list.innerHTML += `<li style='border-bottom:1px solid #ccc; padding:5px;'>${item}</li>`;
            }

            function playSound() {
                // Simple beep
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const g = ctx.createGain();
                osc.connect(g);
                g.connect(ctx.destination);
                osc.start();
                osc.stop(ctx.currentTime + 0.1);
            }

            function triggerFlash() {
                const f = document.createElement('div');
                f.style.cssText = "position:absolute; top:0; left:0; width:100%; height:100%; background:white; transition:opacity 0.5s;";
                document.body.appendChild(f);
                setTimeout(() => f.style.opacity = 0, 50);
                setTimeout(() => f.remove(), 550);
            }

            function checkWinCondition() {
                // Strictly check for 5 badges. No extra badge awarded.
                if (badges === 5 && !gameWon) {
                    gameWon = true;
                    teleportToParty();
                }
            }

            // Music System
            function playBirthdaySong() {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const notes = [
                    { f: 261.63, d: 0.5 }, { f: 261.63, d: 0.5 }, { f: 293.66, d: 1 }, { f: 261.63, d: 1 }, { f: 349.23, d: 1 }, { f: 329.63, d: 2 }, // Happy Birthday to You
                    { f: 261.63, d: 0.5 }, { f: 261.63, d: 0.5 }, { f: 293.66, d: 1 }, { f: 261.63, d: 1 }, { f: 392.00, d: 1 }, { f: 349.23, d: 2 }, // Happy Birthday to You
                    { f: 261.63, d: 0.5 }, { f: 261.63, d: 0.5 }, { f: 523.25, d: 1 }, { f: 440.00, d: 1 }, { f: 349.23, d: 1 }, { f: 329.63, d: 1 }, { f: 293.66, d: 1 }, // Happy Birthday Dear Tripti
                    { f: 466.16, d: 0.5 }, { f: 466.16, d: 0.5 }, { f: 440.00, d: 1 }, { f: 349.23, d: 1 }, { f: 392.00, d: 1 }, { f: 349.23, d: 2 }  // Happy Birthday to You
                ];

                let time = ctx.currentTime;
                notes.forEach(n => {
                    const osc = ctx.createOscillator();
                    const g = ctx.createGain();
                    osc.connect(g);
                    g.connect(ctx.destination);
                    osc.frequency.value = n.f;
                    osc.start(time);
                    g.gain.exponentialRampToValueAtTime(0.00001, time + n.d);
                    osc.stop(time + n.d);
                    time += n.d;
                });
            }

            // NPC Animation System
            // (Populate in createBirthdayZone)

            // Confetti System
            function confettiExplosion() {
                const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff];
                const geo = new THREE.PlaneGeometry(0.1, 0.1); // Size 0.1
                for (let i = 0; i < 100; i++) {
                    const mat = new THREE.MeshBasicMaterial({ color: colors[Math.floor(Math.random() * colors.length)], side: THREE.DoubleSide });
                    const p = new THREE.Mesh(geo, mat);
                    p.position.set(Math.random() * 6 - 3, 10, Math.random() * 6 - 3); // Spawn at y=10 (Roof), Radius 3
                    p.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    p.userData = {
                        vel: new THREE.Vector3(Math.random() * 0.2 - 0.1, -0.05, Math.random() * 0.2 - 0.1), // Slow fall
                        rot: new THREE.Vector3(Math.random() * 0.1, Math.random() * 0.1, Math.random() * 0.1)
                    };
                    scene.add(p);
                    confettiList.push(p);
                }
            }

            function teleportToParty() {
                // Freeze Movement
                playerCanMove = false;

                // Fade Effect
                const overlay = document.createElement('div');
                overlay.style.cssText = "position:fixed; top:0; left:0; width:100%; height:100%; background:black; opacity:0; transition: opacity 2s;";
                document.body.appendChild(overlay);

                setTimeout(() => { overlay.style.opacity = 1; }, 100);

                setTimeout(() => {
                    // Reveal Party
                    partyGroup.visible = true;

                    // Move Characters
                    tripti.position.set(0, 0, 15);
                    tripti.lookAt(0, 0, 0);
                    ninja.position.set(3, 0, 15);
                    ninja.lookAt(0, 0, 0);

                    // Unfreeze Movement
                    playerCanMove = true;

                    // Stop Movement
                    Object.keys(keys).forEach(key => keys[key] = false);

                    // Change Atmosphere
                    scene.background = new THREE.Color(0x1a0b2e); // Dark Violet
                    dirLight.intensity = 0.1; // Dim global light

                    // Add Party Interactables
                    interactables.push({
                        position: new THREE.Vector3(0, 0, 0),
                        radius: 4,
                        label: 'Make a Wish',
                        action: () => {
                            // Blow Out Sequence
                            playSound(); // Breath sound simulated

                            // Animate Flames & Lights
                            let progress = 0;
                            const interval = setInterval(() => {
                                progress += 0.05;
                                const scale = 1 - progress;
                                const intensity = 1 - progress;

                                if (progress >= 1) {
                                    clearInterval(interval);
                                    candleFlames.forEach(f => f.visible = false);
                                    candleLights.forEach(l => l.intensity = 0);

                                    // Trigger Confetti
                                    confettiExplosion();

                                    // Start Orbit Camera
                                    isOrbiting = true;

                                    // Show Birthday Message
                                    const card = document.createElement('div');
                                    card.style.cssText = "position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:white; padding:40px; border-radius:20px; text-align:center; box-shadow: 0 0 50px rgba(255,192,203,0.8); opacity:0; transition:opacity 2s; z-index:1000; max-width: 600px;";
                                    card.innerHTML = `
                                        <button onclick="this.parentElement.remove()" style="position:absolute; top:15px; right:15px; background:none; border:none; font-size:24px; cursor:pointer; color:#ff69b4; font-weight:bold;">âœ•</button>
                                        <h1 style='color:#ff69b4; font-family:sans-serif; margin-top:10px;'>Happy Birthday Tripti!</h1>
                                        <p style='font-size:18px; line-height:1.6; color:#333;'>You are one of the smartest, happy, amazing and funny people i've ever met. Everyone who meets you is lucky and even if they try can't hate you. Keep shining like the star you are! âœ¨</p>
                                    `;
                                    document.body.appendChild(card);
                                    setTimeout(() => card.style.opacity = 1, 100);

                                } else {
                                    candleFlames.forEach(f => f.scale.setScalar(scale));
                                    candleLights.forEach(l => l.intensity = intensity);
                                }
                            }, 50);
                        }
                    });

                    overlay.style.opacity = 0;
                    setTimeout(() => { document.body.removeChild(overlay); }, 2000);

                    // Play Music
                    playBirthdaySong();
                }, 2000);
            }

            // ==========================================
            // 7. INPUTS & ANIMATION
            // ==========================================

            // NOW we can safely call createWorld because interactables is defined
            createWorld();

            // Inputs
            // Click listener removed for pointer lock
            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body && !isOrbiting && playerCanMove) {
                    tripti.rotation.y -= e.movementX * 0.002;
                }
            });

            // Universal Close Logic
            document.body.addEventListener('click', (e) => {
                if (e.target.classList.contains('close-btn') || e.target.innerText === 'Close' || e.target.innerText === 'Close âŒ') {
                    // Hide all menus
                    const menus = ['karaoke-menu', 'pvr-menu', 'inventory-panel', 'mcd-menu', 'photo-result-modal', 'dialogue-overlay', 'movie-gallery-modal'];
                    menus.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.style.display = 'none';
                    });
                    playerCanMove = true;
                }
            });

            // Key Listeners
            window.addEventListener('keydown', (e) => {
                if (keys.hasOwnProperty(e.code)) keys[e.code] = true;
                if (e.code === 'KeyI') {
                    const inv = document.getElementById('inventory-panel');
                    inv.style.display = inv.style.display === 'none' ? 'block' : 'none';
                }

                // Emergency Stop (Q)
                if (e.code === 'KeyQ') {
                    Object.keys(keys).forEach(key => keys[key] = false);
                    joystickInput = { x: 0, y: 0 };
                    const stick = document.getElementById('joystick-stick');
                    if (stick) stick.style.transform = "translate(-50%, -50%)";
                }

                // Interaction Logic
                if (activeInteraction) {
                    // 'E' for Action OR Sit (User Preference)
                    if (e.code === 'KeyE') {
                        activeInteraction.action();
                    }
                    // 'S' for Sit (Specific)
                    if (e.code === 'KeyS' && activeInteraction.type === 'sit') {
                        activeInteraction.action();
                    }
                }

                // Global Close / Stand Up (X)
                if (e.key === 'x' || e.key === 'X') {
                    // 1. Close All Menus
                    const menus = ['karaoke-menu', 'pvr-menu', 'inventory-panel', 'mcd-menu', 'photo-result-modal', 'dialogue-overlay', 'movie-gallery-modal'];
                    menus.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) el.style.display = 'none';
                    });

                    // 2. Unfreeze Player
                    playerCanMove = true;

                    // 3. Reset Camera Orbit
                    isOrbiting = false;

                    // 4. Stand Up Logic
                    if (isSittingWithSuga || isSittingInPhotobooth) {
                        isSittingWithSuga = false;
                        isSittingInPhotobooth = false;

                        // Reset Tripti position slightly offset
                        tripti.position.add(new THREE.Vector3(1, 0, 1));
                        tripti.position.y = 0;
                    }
                }

                // Toggle Camera Lock
                if (e.code === 'KeyM') {
                    if (document.pointerLockElement === document.body) {
                        document.exitPointerLock();
                    } else {
                        document.body.requestPointerLock();
                    }
                }
            });

            window.addEventListener('keyup', (e) => {
                if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
            });

            // Loop
            const clock = new THREE.Clock();
            const speed = 0.2;
            let isOrbiting = false;

            function animate() {
                requestAnimationFrame(animate);

                // Confetti Animation
                for (let i = confettiList.length - 1; i >= 0; i--) {
                    const p = confettiList[i];
                    p.position.y -= 0.05; // Move down
                    p.rotation.x += p.userData.rot.x;
                    p.rotation.y += p.userData.rot.y;

                    if (p.position.y < 0) {
                        scene.remove(p);
                        confettiList.splice(i, 1);
                    }
                }

                // NPC Animation (Clapping)
                const time = Date.now() * 0.01;
                guestsList.forEach(g => {
                    g.scale.setScalar(1 + Math.sin(time) * 0.1); // Pulse/Clap
                });

                // Movement Logic (Keyboard + Joystick)
                if (playerCanMove && !isOrbiting) {
                    // Movement (Local Space)
                    let moveZ = 0;
                    let moveX = 0;

                    // Keyboard
                    if (keys.ArrowUp) moveZ = -1;
                    if (keys.ArrowDown) moveZ = 1;
                    if (keys.ArrowLeft) moveX = -1;
                    if (keys.ArrowRight) moveX = 1;

                    // Joystick Override
                    if (joystickInput.x !== 0 || joystickInput.y !== 0) {
                        moveX = joystickInput.x;
                        moveZ = joystickInput.y;
                    }

                    if (moveZ !== 0 || moveX !== 0) {
                        tripti.translateZ(moveZ * speed);
                        tripti.translateX(moveX * speed);
                        tripti.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.1; // Bobbing
                    } else {
                        tripti.position.y = 0;
                    }

                } else if (isOrbiting) {
                    // Orbit Camera
                    const orbitSpeed = 0.0005;
                    const radius = 15;
                    const x = radius * Math.sin(Date.now() * orbitSpeed);
                    const z = radius * Math.cos(Date.now() * orbitSpeed);
                    camera.position.set(x, 8, z);
                    camera.lookAt(0, 2, 0); // Look at cake
                }

                // Camera Follow (Always active unless orbiting)
                if (!isOrbiting) {
                    const relativeOffset = new THREE.Vector3(0, 4, 6);
                    const cameraOffset = relativeOffset.applyMatrix4(tripti.matrixWorld);
                    camera.position.lerp(cameraOffset, 0.1);
                    camera.lookAt(tripti.position.x, tripti.position.y + 2, tripti.position.z);

                    // Ninja Logic
                    if (ninja.position.distanceTo(tripti.position) > 3) {
                        ninja.lookAt(tripti.position);
                        ninja.translateZ(speed * 0.9);
                    }
                }

                // Dog Tail Animation
                const tailSpeed = time * 10;
                dogTails.forEach(t => {
                    t.rotation.z = Math.sin(tailSpeed) * 0.5; // Wag
                });

                // Dog AI Logic
                const now = Date.now();
                cafeDogs.forEach(dog => {
                    const data = dog.userData;

                    if (!data.isMoving) {
                        // Idle
                        if (now > data.moveTimer) {
                            // Start moving
                            data.isMoving = true;
                            data.moveTimer = now + 2000 + Math.random() * 3000; // Move for 2-5s

                            // Pick random direction
                            const angle = Math.random() * Math.PI * 2;
                            data.velocity.set(Math.sin(angle) * 0.03, 0, Math.cos(angle) * 0.03);

                            // Face direction
                            dog.rotation.y = Math.atan2(data.velocity.x, data.velocity.z);
                        }
                    } else {
                        // Moving
                        dog.position.add(data.velocity);

                        // Hop
                        dog.position.y = 0.5 + Math.sin((now * 0.01) + data.hopOffset) * 0.1;

                        // Leash Logic (World Space check is tricky since they are in a group)
                        // Actually, dog.position is local to 'group' (the building group).
                        // data.homePos is World Space.
                        // We need to compare World Positions.
                        // But wait, createDogNPC added them to 'group' (the building group).
                        // The building group is at 'worldPos'.
                        // So dog.position is relative to the building center.
                        // data.homePos was calculated as worldPos + relativePos.
                        // Let's just check distance from their spawn point (relative).

                        // Re-calculating homePos to be relative for easier check
                        // In createDogNPC: dogGroup.position.set(x, ... z);
                        // So 'x' and 'z' passed to createDogNPC are the relative home coords.
                        // Let's store relative home pos instead.

                        // FIX: We need to update createDogNPC to store relative home pos.
                        // But since I can't easily go back and edit that chunk without re-doing it, 
                        // I will assume I can access the initial position from the logic I just added.
                        // Wait, I added: homePos: new THREE.Vector3(worldPos.x + x, 0, worldPos.z + z)
                        // That is WORLD pos.
                        // The dog's current WORLD pos is group.position + dog.position.

                        const currentWorldPos = new THREE.Vector3().copy(dog.position).add(dog.parent.position);
                        const dist = currentWorldPos.distanceTo(data.homePos);

                        if (dist > 8) {
                            // Turn back home
                            const dirToHome = new THREE.Vector3().subVectors(data.homePos, currentWorldPos).normalize();
                            data.velocity.copy(dirToHome).multiplyScalar(0.03);
                            dog.rotation.y = Math.atan2(data.velocity.x, data.velocity.z);
                        }

                        // Stop
                        if (now > data.moveTimer) {
                            data.isMoving = false;
                            data.moveTimer = now + 1000 + Math.random() * 2000; // Idle for 1-3s
                            dog.position.y = 0.5; // Reset height
                        }
                    }
                });

                if (playerCanMove && !isOrbiting) {
                    // Movement (Local Space)
                    let moveZ = 0;
                    let moveX = 0;
                    if (keys.ArrowUp) moveZ = -1;
                    if (keys.ArrowDown) moveZ = 1;
                    if (keys.ArrowLeft) moveX = -1;
                    if (keys.ArrowRight) moveX = 1;

                    if (moveZ !== 0 || moveX !== 0) {
                        tripti.translateZ(moveZ * speed);
                        tripti.translateX(moveX * speed);
                        tripti.position.y = Math.abs(Math.sin(Date.now() * 0.01)) * 0.1; // Bobbing
                    } else {
                        tripti.position.y = 0;
                    }

                    // Camera Follow
                    const relativeOffset = new THREE.Vector3(0, 4, 6);
                    const cameraOffset = relativeOffset.applyMatrix4(tripti.matrixWorld);
                    camera.position.lerp(cameraOffset, 0.1);
                    camera.lookAt(tripti.position.x, tripti.position.y + 2, tripti.position.z);

                    // Ninja Logic
                    if (ninja.position.distanceTo(tripti.position) > 3) {
                        ninja.lookAt(tripti.position);
                        ninja.translateZ(speed * 0.9);
                    }
                } else {
                    // Orbit Camera
                    const orbitSpeed = 0.0005;
                    const radius = 15;
                    const x = radius * Math.sin(Date.now() * orbitSpeed);
                    const z = radius * Math.cos(Date.now() * orbitSpeed);
                    camera.position.set(x, 8, z);
                    camera.lookAt(0, 2, 0); // Look at cake
                }

                // UI Update for Photobooth
                if (isSittingInPhotobooth) {
                    activeInteraction = null; // Prevent double-triggering 'Sit' logic
                    promptUI.innerText = "Press E to Take Photos | Press X to Stand Up";
                    promptUI.style.display = 'block';
                } else {
                    checkInteractions();
                }

                // Check McDonalds (No Interactable, just area) - REMOVED
                // if (tripti.position.distanceTo(new THREE.Vector3(0, 0, 25)) < 10) {
                //    awardBadge('McDelight');
                // }

                // Waiter Animation
                if (mcdWaiter && waiterState !== 'idle') {
                    const speed = 0.05;
                    const target = waiterState === 'delivering' ? waiterTarget : waiterHomePos;

                    // Move
                    const dir = new THREE.Vector3().subVectors(target, mcdWaiter.position).normalize();
                    const dist = mcdWaiter.position.distanceTo(target);

                    if (dist > 0.1) {
                        mcdWaiter.position.add(dir.multiplyScalar(speed));
                        mcdWaiter.lookAt(target);
                    } else {
                        // Arrived
                        if (waiterState === 'delivering') {
                            waiterState = 'returning';
                            if (mcdWaiter.userData.tray) mcdWaiter.userData.tray.visible = false;

                            if (typeof spawnMcdFood === 'function') {
                                spawnMcdFood(mcdTable1);
                            } else {
                                console.error("spawnMcdFood function missing!");
                            }

                            awardBadge('McDelight');
                            alert('Happy Birthday Tripti! ðŸŽ‚');
                        } else if (waiterState === 'returning') {
                            waiterState = 'idle';
                            mcdWaiter.rotation.set(0, 0, 0); // Reset rotation
                        }
                    }
                }

                renderer.render(scene, camera);
            }

            function spawnMcdFood(table) {
                if (!table) return;

                // Burger
                const burger = new THREE.Group();
                const bun = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0xD2691E }));
                burger.add(bun);
                const meat = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 0.05, 16), new THREE.MeshStandardMaterial({ color: 0x3e2723 }));
                meat.position.y = 0.08;
                burger.add(meat);
                burger.position.set(0, 0.6, 0);
                table.add(burger);

                // Fries
                const friesBox = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.05), new THREE.MeshStandardMaterial({ color: 0xDD2C00 }));
                friesBox.position.set(0.3, 0.65, 0.2);
                table.add(friesBox);
                const fries = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.02), new THREE.MeshStandardMaterial({ color: 0xFFD700 }));
                fries.position.y = 0.1;
                friesBox.add(fries);

                // Drink
                const drink = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.06, 0.2, 16), new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 }));
                drink.position.set(-0.3, 0.65, -0.2);
                table.add(drink);
                const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.3), new THREE.MeshStandardMaterial({ color: 0xff0000 }));
                straw.position.set(0, 0.1, 0);
                straw.rotation.z = 0.2;
                drink.add(straw);
            }

            // Food Spawning System
            function spawnSuchwitaFood(items) {
                if (!suchwitaTableGroup) return;
                // Clear previous food
                while (suchwitaTableGroup.children.length > 0) {
                    suchwitaTableGroup.remove(suchwitaTableGroup.children[0]);
                }

                items.forEach((item, index) => {
                    const foodGroup = new THREE.Group();

                    // Random Offset (Spread out on table)
                    // Table is 4x1.5. 
                    // X range: -1.5 to 1.5 (safe)
                    // Z range: -0.5 to 0.5 (safe)
                    const offsetX = (Math.random() - 0.5) * 2.5;
                    const offsetZ = (Math.random() - 0.5) * 0.8;
                    foodGroup.position.set(offsetX, 0, offsetZ);
                    foodGroup.rotation.y = Math.random() * Math.PI;

                    // Scale down to fit nicely (0.2 - 0.3 range)
                    foodGroup.scale.setScalar(0.8);

                    if (item === 'Strawberry Iced Tea') {
                        // Red Cylinder (Glass + Liquid)
                        const glass = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.3, 16), new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.3 }));
                        glass.position.y = 0.15;
                        foodGroup.add(glass);

                        const liquid = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.25, 16), new THREE.MeshStandardMaterial({ color: 0xff0000 })); // Red Liquid
                        liquid.position.y = 0.12;
                        foodGroup.add(liquid);

                        // Straw
                        const straw = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.4), new THREE.MeshStandardMaterial({ color: 0xffffff }));
                        straw.position.set(0.05, 0.2, 0);
                        straw.rotation.z = 0.2;
                        foodGroup.add(straw);

                    } else if (item === 'Eggroll Shawarma') {
                        // White Cylinder (Wrapper)
                        const wrap = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.3, 16), new THREE.MeshStandardMaterial({ color: 0xffffff })); // White
                        wrap.rotation.z = Math.PI / 2;
                        wrap.position.y = 0.08;
                        foodGroup.add(wrap);

                        // Filling (Beige)
                        const filling = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.32, 16), new THREE.MeshStandardMaterial({ color: 0xd2b48c }));
                        filling.rotation.z = Math.PI / 2;
                        filling.position.y = 0.08;
                        foodGroup.add(filling);

                    } else if (item === 'Strawberry Cornflakes') {
                        // White Hemisphere (Bowl)
                        const bowl = new THREE.Mesh(new THREE.SphereGeometry(0.15, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0xffffff, side: THREE.DoubleSide }));
                        bowl.rotation.x = Math.PI;
                        bowl.position.y = 0.15;
                        foodGroup.add(bowl);

                        // Milk (Pink)
                        const milk = new THREE.Mesh(new THREE.CircleGeometry(0.14, 16), new THREE.MeshStandardMaterial({ color: 0xffc0cb }));
                        milk.rotation.x = -Math.PI / 2;
                        milk.position.y = 0.12;
                        foodGroup.add(milk);

                    } else if (item === 'Rum & Raisin Chocolate') {
                        // Brown Box
                        const choco = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.05, 0.3), new THREE.MeshStandardMaterial({ color: 0x3e2723 })); // Dark Brown
                        choco.position.y = 0.025;
                        foodGroup.add(choco);
                    }

                    suchwitaTableGroup.add(foodGroup);
                });
            }

            // Resize Handler
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Start
            animate();
        } catch (err) {
            const overlay = document.getElementById('error-overlay');
            overlay.style.display = 'block';
            overlay.innerHTML += `SETUP ERROR:\n${err.message}\n\nStack:\n${err.stack}`;
        }

    </script>
</body>

</html>